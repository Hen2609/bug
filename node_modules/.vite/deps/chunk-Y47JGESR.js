import {
  require_BufferedWriter,
  require_StringWriter
} from "./chunk-4I5EL46D.js";
import {
  require_attrs
} from "./chunk-VZJVGXZO.js";
import {
  require_data_marko
} from "./chunk-LXDEAGV3.js";
import {
  require_escape_xml
} from "./chunk-3XM22MEA.js";
import {
  require_renderable
} from "./chunk-DOCKNWKO.js";
import {
  require_RenderResult,
  require_createOut,
  require_src
} from "./chunk-XFSNMVI3.js";
import {
  require_parse_html
} from "./chunk-BYPQ4JD2.js";
import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/marko/src/runtime/html/create-readable/index-browser.js
var require_index_browser = __commonJS({
  "node_modules/marko/src/runtime/html/create-readable/index-browser.js"(exports, module) {
    var encoder = new TextEncoder();
    var noop = function() {
    };
    module.exports = function(data) {
      var transformStream = new TransformStream();
      var writer = transformStream.writable.getWriter();
      var facade = {
        write: function(string) {
          writer.write(encoder.encode(string));
        },
        end: function() {
          writer.close();
        }
      };
      var out = this.createOut(
        data && data.$global,
        facade,
        void 0,
        this.___shouldBuffer
      );
      out.once("error", (err) => {
        facade.write = facade.end = noop;
        writer.abort(err);
      });
      this.render(data, out);
      out.end();
      return transformStream.readable;
    };
  }
});

// node_modules/self-closing-tags/index.js
var require_self_closing_tags = __commonJS({
  "node_modules/self-closing-tags/index.js"(exports, module) {
    "use strict";
    var svgElements = [
      "circle",
      "ellipse",
      "line",
      "path",
      "polygon",
      "polyline",
      "rect",
      "stop",
      "use"
    ];
    var voidElements = [
      "area",
      "base",
      "br",
      "col",
      "command",
      "embed",
      "hr",
      "img",
      "input",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ];
    module.exports = voidElements.concat(svgElements);
    module.exports.voidElements = voidElements;
    module.exports.svgElements = svgElements;
  }
});

// node_modules/marko/src/runtime/html/AsyncStream.js
var require_AsyncStream = __commonJS({
  "node_modules/marko/src/runtime/html/AsyncStream.js"(exports, module) {
    "use strict";
    var EventEmitter = require_src();
    var StringWriter = require_StringWriter();
    var BufferedWriter = require_BufferedWriter();
    var RenderResult = require_RenderResult();
    var attrsHelper = require_attrs();
    var markoAttr = require_data_marko();
    var escapeXmlHelper = require_escape_xml();
    var parseHTML = require_parse_html();
    var escapeXmlOrNullish = escapeXmlHelper.x;
    var escapeXmlString = escapeXmlHelper.___escapeXML;
    var selfClosingTags = require_self_closing_tags();
    function noop() {
    }
    var voidWriter = {
      write: noop,
      script: noop,
      merge: noop,
      clear: noop,
      get: function() {
        return [];
      },
      toString: function() {
        return "";
      }
    };
    function State(root, stream, writer, events) {
      this.root = root;
      this.stream = stream;
      this.writer = writer;
      this.events = events;
      this.finished = false;
    }
    function escapeEndingComment(text) {
      return text.replace(/-->/g, "--&gt;");
    }
    function AsyncStream(global, writer, parentOut) {
      if (parentOut === null) {
        throw new Error("illegal state");
      }
      var finalGlobal = this.attributes = global || {};
      var originalStream;
      var state;
      if (parentOut) {
        state = parentOut._state;
        originalStream = state.stream;
      } else {
        var events = finalGlobal.events = writer && writer.on ? writer : new EventEmitter();
        if (writer) {
          originalStream = writer;
          writer = new BufferedWriter(writer);
        } else {
          writer = originalStream = new StringWriter();
        }
        state = new State(this, originalStream, writer, events);
        writer.state = state;
      }
      finalGlobal.runtimeId = finalGlobal.runtimeId || "M";
      this.global = finalGlobal;
      this.stream = originalStream;
      this._state = state;
      this._ended = false;
      this._remaining = 1;
      this._lastCount = 0;
      this._last = void 0;
      this._parentOut = parentOut;
      this.data = {};
      this.writer = writer;
      writer.stream = this;
      this._sync = false;
      this._stack = void 0;
      this.name = void 0;
      this._timeoutId = void 0;
      this._node = void 0;
      this._elStack = void 0;
      this.___components = null;
      this.___assignedComponentDef = null;
      this.___assignedKey = null;
      this.___assignedCustomEvents = null;
      this.___isLast = false;
    }
    AsyncStream.DEFAULT_TIMEOUT = 1e4;
    AsyncStream.INCLUDE_STACK = typeof process !== "undefined" && true;
    AsyncStream.enableAsyncStackTrace = function() {
      AsyncStream.INCLUDE_STACK = true;
    };
    var proto = AsyncStream.prototype = {
      constructor: AsyncStream,
      ___host: typeof document === "object" && document,
      ___isOut: true,
      sync: function() {
        this._sync = true;
      },
      isSync: function() {
        return this._sync === true;
      },
      write: function(str) {
        if (str != null) {
          this.writer.write(str.toString());
        }
        return this;
      },
      script: function(str) {
        if (str != null) {
          this.writer.script(str.toString());
        }
        return this;
      },
      ___getOutput: function() {
        return this._state.writer.toString();
      },
      getOutput: function() {
        return this.___getOutput();
      },
      toString: function() {
        return this._state.writer.toString();
      },
      ___getResult: function() {
        this._result = this._result || new RenderResult(this);
        return this._result;
      },
      beginAsync: function(options) {
        if (this._sync) {
          throw new Error("beginAsync() not allowed when using renderSync()");
        }
        var state = this._state;
        var currentWriter = this.writer;
        var newWriter = new StringWriter();
        var newStream = new AsyncStream(this.global, currentWriter, this);
        newWriter.state = state;
        this.writer = newWriter;
        newWriter.stream = this;
        newWriter.next = currentWriter.next;
        currentWriter.next = newWriter;
        var timeout;
        var name;
        this._remaining++;
        if (options != null) {
          if (typeof options === "number") {
            timeout = options;
          } else {
            timeout = options.timeout;
            if (options.last === true) {
              if (timeout == null) {
                timeout = 0;
              }
              this._lastCount++;
              newStream.___isLast = true;
            }
            name = options.name;
          }
        }
        if (timeout == null) {
          timeout = AsyncStream.DEFAULT_TIMEOUT;
        }
        newStream._stack = AsyncStream.INCLUDE_STACK ? new Error() : null;
        newStream.name = name;
        if (timeout > 0) {
          newStream._timeoutId = setTimeout(function() {
            newStream.error(
              new Error(
                "Async fragment " + (name ? "(" + name + ") " : "") + "timed out after " + timeout + "ms"
              )
            );
          }, timeout);
        }
        state.events.emit("beginAsync", {
          out: newStream,
          parentOut: this
        });
        return newStream;
      },
      _doFinish: function() {
        var state = this._state;
        state.finished = true;
        if (state.writer.end) {
          state.writer.end();
        } else {
          state.events.emit("finish", this.___getResult());
        }
      },
      end: function(data) {
        if (this._ended === true) {
          return;
        }
        this._ended = true;
        var remaining = --this._remaining;
        if (data != null) {
          this.write(data);
        }
        var currentWriter = this.writer;
        this.writer = voidWriter;
        currentWriter.stream = null;
        this._flushNext(currentWriter);
        var parentOut = this._parentOut;
        if (parentOut === void 0) {
          if (remaining === 0) {
            this._doFinish();
          } else if (remaining - this._lastCount === 0) {
            this._emitLast();
          }
        } else {
          var timeoutId = this._timeoutId;
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          if (remaining === 0) {
            parentOut._handleChildDone(this);
          } else if (remaining - this._lastCount === 0) {
            this._emitLast();
          }
        }
        return this;
      },
      _handleChildDone: function(childOut) {
        var remaining = --this._remaining;
        if (remaining === 0) {
          var parentOut = this._parentOut;
          if (parentOut === void 0) {
            this._doFinish();
          } else {
            parentOut._handleChildDone(this);
          }
        } else {
          if (childOut.___isLast) {
            this._lastCount--;
          }
          if (remaining - this._lastCount === 0) {
            this._emitLast();
          }
        }
      },
      _flushNext: function(currentWriter) {
        var nextWriter = currentWriter.next;
        if (nextWriter) {
          currentWriter.merge(nextWriter);
          currentWriter.next = nextWriter.next;
          var nextStream = nextWriter.stream;
          if (nextStream) {
            nextStream.writer = currentWriter;
            currentWriter.stream = nextStream;
          }
        }
      },
      on: function(event, callback) {
        var state = this._state;
        if (event === "finish" && state.finished === true) {
          callback(this.___getResult());
        } else if (event === "last") {
          this.onLast(callback);
        } else {
          state.events.on(event, callback);
        }
        return this;
      },
      once: function(event, callback) {
        var state = this._state;
        if (event === "finish" && state.finished === true) {
          callback(this.___getResult());
        } else if (event === "last") {
          this.onLast(callback);
        } else {
          state.events.once(event, callback);
        }
        return this;
      },
      onLast: function(callback) {
        var lastArray = this._last;
        if (lastArray === void 0) {
          this._last = [callback];
        } else {
          lastArray.push(callback);
        }
        return this;
      },
      _emitLast: function() {
        if (this._last) {
          var i = 0;
          var lastArray = this._last;
          this._last = void 0;
          (function next() {
            if (i === lastArray.length) {
              return;
            }
            var lastCallback = lastArray[i++];
            lastCallback(next);
            if (lastCallback.length === 0) {
              next();
            }
          })();
        }
      },
      emit: function(type, arg) {
        var events = this._state.events;
        switch (arguments.length) {
          case 1:
            events.emit(type);
            break;
          case 2:
            events.emit(type, arg);
            break;
          default:
            events.emit.apply(events, arguments);
            break;
        }
        return this;
      },
      removeListener: function() {
        var events = this._state.events;
        events.removeListener.apply(events, arguments);
        return this;
      },
      prependListener: function() {
        var events = this._state.events;
        events.prependListener.apply(events, arguments);
        return this;
      },
      pipe: function(stream) {
        this._state.stream.pipe(stream);
        return this;
      },
      error: function(e) {
        var name = this.name;
        var stack = this._stack;
        if (stack)
          stack = getNonMarkoStack(stack);
        if (!(e instanceof Error)) {
          e = new Error(JSON.stringify(e));
        }
        if (name || stack) {
          e.message += "\nRendered by" + (name ? " " + name : "") + (stack ? ":\n" + stack : "");
        }
        try {
          this.emit("error", e);
        } finally {
          this.end();
        }
        return this;
      },
      flush: function() {
        var state = this._state;
        if (!state.finished) {
          var writer = state.writer;
          if (writer && writer.scheduleFlush) {
            writer.scheduleFlush();
          }
        }
        return this;
      },
      createOut: function() {
        var newOut = new AsyncStream(this.global);
        newOut.on("error", this.emit.bind(this, "error"));
        this._state.events.emit("beginDetachedAsync", {
          out: newOut,
          parentOut: this
        });
        return newOut;
      },
      ___elementDynamic: function(tagName, elementAttrs, key, componentDef, props) {
        var str = "<" + tagName + markoAttr(this, componentDef, props, key) + attrsHelper(elementAttrs);
        if (selfClosingTags.voidElements.indexOf(tagName) !== -1) {
          str += ">";
        } else if (selfClosingTags.svgElements.indexOf(tagName) !== -1) {
          str += "/>";
        } else {
          str += "></" + tagName + ">";
        }
        this.write(str);
      },
      element: function(tagName, elementAttrs, openTagOnly) {
        var str = "<" + tagName + attrsHelper(elementAttrs) + ">";
        if (openTagOnly !== true) {
          str += "</" + tagName + ">";
        }
        this.write(str);
      },
      ___beginElementDynamic: function(name, elementAttrs, key, componentDef, props) {
        var str = "<" + name + markoAttr(this, componentDef, props, key) + attrsHelper(elementAttrs) + ">";
        this.write(str);
        if (this._elStack) {
          this._elStack.push(name);
        } else {
          this._elStack = [name];
        }
      },
      beginElement: function(name, elementAttrs) {
        var str = "<" + name + attrsHelper(elementAttrs) + ">";
        this.write(str);
        if (this._elStack) {
          this._elStack.push(name);
        } else {
          this._elStack = [name];
        }
      },
      endElement: function() {
        var tagName = this._elStack.pop();
        this.write("</" + tagName + ">");
      },
      comment: function(str) {
        this.write("<!--" + escapeEndingComment(str) + "-->");
      },
      text: function(str) {
        this.write(escapeXmlOrNullish(str));
      },
      bf: function(key, component, preserve) {
        if (preserve) {
          this.write("<!--F#" + escapeXmlString(key) + "-->");
        }
        if (this._elStack) {
          this._elStack.push(preserve);
        } else {
          this._elStack = [preserve];
        }
      },
      ef: function() {
        var preserve = this._elStack.pop();
        if (preserve) {
          this.write("<!--F/-->");
        }
      },
      ___getNode: function(host) {
        var node = this._node;
        if (!node) {
          var nextEl;
          var fragment;
          var html = this.___getOutput();
          if (!host)
            host = this.___host;
          var doc = host.ownerDocument || host;
          if (html) {
            node = parseHTML(html);
            if (node && node.nextSibling) {
              fragment = doc.createDocumentFragment();
              do {
                nextEl = node.nextSibling;
                fragment.appendChild(node);
              } while (node = nextEl);
              node = fragment;
            }
          }
          this._node = node || doc.createDocumentFragment();
        }
        return node;
      },
      then: function(fn, fnErr) {
        var out = this;
        var promise = new Promise(function(resolve, reject) {
          out.on("error", reject);
          out.on("finish", function(result) {
            resolve(result);
          });
        });
        return Promise.resolve(promise).then(fn, fnErr);
      },
      catch: function(fnErr) {
        return this.then(void 0, fnErr);
      },
      c: function(componentDef, key, customEvents) {
        this.___assignedComponentDef = componentDef;
        this.___assignedKey = key;
        this.___assignedCustomEvents = customEvents;
      }
    };
    proto.w = proto.write;
    proto.___endElement = proto.endElement;
    module.exports = AsyncStream;
    function getNonMarkoStack(error) {
      return error.stack.toString().split("\n").slice(1).filter((line) => !/\/node_modules\/marko\//.test(line)).join("\n");
    }
  }
});

// node_modules/marko/src/runtime/html/index.js
var require_html = __commonJS({
  "node_modules/marko/src/runtime/html/index.js"(exports) {
    exports.t = function createTemplate(typeName) {
      return new Template(typeName);
    };
    function Template(typeName) {
      this.___typeName = typeName;
    }
    Template.prototype.stream = require_index_browser();
    var AsyncStream = require_AsyncStream();
    require_createOut().___setCreateOut(
      Template.prototype.createOut = function createOut(globalData, writer, parentOut, buffer) {
        return new AsyncStream(globalData, writer, parentOut, buffer);
      }
    );
    require_renderable()(Template.prototype);
  }
});

export {
  require_html
};
//# sourceMappingURL=chunk-Y47JGESR.js.map
