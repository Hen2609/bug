{
  "version": 3,
  "sources": ["../../marko/src/core-tags/core/await/AsyncValue.js", "../../marko/src/core-tags/core/await/renderer.js"],
  "sourcesContent": ["var queueMicrotask = require(\"../../../runtime/queueMicrotask\");\n\nfunction AsyncValue() {\n  /**\n   * The data that was provided via call to resolve(data).\n   * This property is assumed to be public and available for inspection.\n   */\n  this.___value = undefined;\n\n  /**\n   * The data that was provided via call to reject(err)\n   * This property is assumed to be public and available for inspection.\n   */\n  this.___error = undefined;\n\n  /**\n   * The queue of callbacks that are waiting for data\n   */\n  this.___callbacks = undefined;\n\n  /**\n   * The state of the data holder (STATE_INITIAL, STATE_RESOLVED, or STATE_REJECTED)\n   */\n  this.___settled = false;\n}\n\nfunction notifyCallbacks(asyncValue, err, value) {\n  var callbacks = asyncValue.___callbacks;\n  if (callbacks) {\n    // clear out the registered callbacks (we still have reference to the original value)\n    asyncValue.___callbacks = undefined;\n\n    // invoke all of the callbacks and use their scope\n    for (var i = 0; i < callbacks.length; i++) {\n      // each callback is actually an object with \"scope and \"callback\" properties\n      var callback = callbacks[i];\n      callback(err, value);\n    }\n  }\n}\n\nAsyncValue.prototype = {\n  /**\n   * Adds a callback to the queue. If there is not a pending request to load data\n   * and we have a \"loader\" then we will use that loader to request the data.\n   * The given callback will be invoked when there is an error or resolved data\n   * available.\n   */\n  ___done: function (callback) {\n    // Do we already have data or error?\n    if (this.___settled) {\n      // invoke the callback immediately\n      return callback(this.___error, this.___value);\n    }\n\n    var callbacks = this.___callbacks || (this.___callbacks = []);\n    callbacks.push(callback);\n  },\n\n  /**\n   * This method will trigger any callbacks to be notified of rejection (error).\n   * If this data holder has a loader then the data holder will be returned to\n   * its initial state so that any future requests to load data will trigger a\n   * new load call.\n   */\n  ___reject: function (err) {\n    if (this.___settled) {\n      return;\n    }\n\n    // remember the error\n    this.___error = err;\n\n    // Go to the rejected state if we don't have a loader.\n    // If we do have a loader then return to the initial state\n    // (we do this so that next call to done() will trigger load\n    // again in case the error was transient).\n    this.___settled = true;\n\n    // always notify callbacks regardless of whether or not we return to the initial state\n    notifyCallbacks(this, err, null);\n  },\n\n  /**\n   * This method will trigger any callbacks to be notified of data.\n   */\n  ___resolve: function (value) {\n    if (this.___settled) {\n      return;\n    }\n\n    if (value && typeof value.then === \"function\") {\n      var asyncValue = this;\n\n      var finalPromise = value.then(\n        function onFulfilled(value) {\n          queueMicrotask(asyncValue.___resolve.bind(asyncValue, value));\n        },\n        function onRejected(err) {\n          queueMicrotask(asyncValue.___reject.bind(asyncValue, err));\n        }\n      );\n\n      if (finalPromise.done) {\n        finalPromise.done();\n      }\n    } else {\n      // remember the state\n      this.___value = value;\n\n      // go to the resolved state\n      this.___settled = true;\n\n      // notify callbacks\n      notifyCallbacks(this, null, value);\n    }\n  }\n};\n\nmodule.exports = AsyncValue;\n", "\"use strict\";\nvar complain = \"MARKO_DEBUG\" && require(\"complain\");\nvar AsyncValue = require(\"./AsyncValue\");\n\nfunction safeRenderBody(renderBody, targetOut, data) {\n  try {\n    renderBody(targetOut, data);\n  } catch (err) {\n    return err;\n  }\n}\n\nfunction requestData(provider, timeout) {\n  var asyncValue = new AsyncValue();\n\n  if (typeof provider === \"function\") {\n    // eslint-disable-next-line no-constant-condition\n    if (\"MARKO_DEBUG\") {\n      complain(\n        \"Passing a callback function to the <await> tag has been deprecated, please use a promise instead.\",\n        { level: 1, locationIndex: 3 }\n      );\n    }\n\n    var callback = function (err, data) {\n      if (err) {\n        asyncValue.___reject(err);\n      } else {\n        asyncValue.___resolve(data);\n      }\n    };\n\n    var value =\n      provider.length === 1\n        ? // one argument so only provide callback to function call\n          provider(callback)\n        : // two arguments so provide args and callback to function call\n          provider(null, callback);\n\n    if (value !== undefined) {\n      asyncValue.___resolve(value);\n    }\n  } else {\n    // Assume the provider is a data object...\n    asyncValue.___resolve(provider);\n  }\n\n  if (timeout == null) {\n    timeout = 10000;\n  }\n\n  var error;\n  var errorMsg = \"Timed out after \" + timeout + \"ms\";\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    // Make sure we have a meaningful stack trace in development preparing the stacktrace upfront.\n    // If we create it inside the setTimeout, we will end up with a short, not meaningful, stack trace\n    // We only do it in development to avoid overhead in production\n    error = new Error(errorMsg);\n  }\n  if (timeout > 0) {\n    let timeoutId = setTimeout(function () {\n      timeoutId = null;\n      if (!error) error = new Error(errorMsg);\n      error.code = \"ERR_AWAIT_TIMEDOUT\";\n      error.name = \"TimeoutError\";\n      asyncValue.___reject(error);\n    }, timeout);\n\n    asyncValue.___done(function () {\n      if (timeoutId != null) {\n        clearTimeout(timeoutId);\n      }\n    });\n  }\n\n  return asyncValue;\n}\n\nconst LAST_OPTIONS = { last: true, name: \"await:finish\" };\n\nmodule.exports = function awaitTag(input, out) {\n  var clientReorder =\n    typeof window === \"undefined\" &&\n    input.clientReorder === true &&\n    !out.isVDOM;\n\n  var name = input.name || input._name;\n  var timeout = input.timeout;\n  var provider = input._provider;\n  var asyncValue = requestData(provider, timeout);\n  var placeholderRenderer = input.placeholder && input.placeholder.renderBody;\n\n  if (asyncValue.___settled) {\n    renderContents(asyncValue.___error, asyncValue.___value, input, out);\n    return;\n  }\n\n  var asyncOut;\n  var clientReorderContext;\n\n  var awaitInfo = {\n    name: name,\n    clientReorder: clientReorder,\n    dataProvider: provider\n  };\n\n  if (clientReorder) {\n    awaitInfo.after = input.showAfter;\n\n    clientReorderContext =\n      out.global.___clientReorderContext ||\n      (out.global.___clientReorderContext = {\n        instances: [],\n        nextId: 0\n      });\n\n    var id = (awaitInfo.id = input.name || clientReorderContext.nextId++);\n    var placeholderIdAttrValue = \"afph\" + id;\n\n    if (placeholderRenderer) {\n      out.write('<span id=\"' + placeholderIdAttrValue + '\">');\n      placeholderRenderer(out);\n      out.write(\"</span>\");\n    } else {\n      out.write('<noscript id=\"' + placeholderIdAttrValue + '\"></noscript>');\n    }\n\n    // If `client-reorder` is enabled then we asynchronously render the await instance to a new\n    // \"out\" instance so that we can Write to a temporary in-memory buffer.\n    asyncOut = awaitInfo.out = out.createOut();\n\n    var oldEmit = asyncOut.emit;\n\n    // Since we are rendering the await instance to a new and separate out,\n    // we want to proxy any child events to the main AsyncWriter in case anyone is interested\n    // in those events. This is also needed for the following events to be handled correctly:\n    //\n    // - await:begin\n    // - await:beforeRender\n    // - await:finish\n    //\n    asyncOut.emit = function (event) {\n      if (event !== \"finish\" && event !== \"error\") {\n        // We don't want to proxy the finish and error events since those are\n        // very specific to the AsyncWriter associated with the await instance\n        out.emit.apply(out, arguments);\n      }\n\n      oldEmit.apply(asyncOut, arguments);\n    };\n\n    if (clientReorderContext.instances) {\n      clientReorderContext.instances.push(awaitInfo);\n    }\n\n    out.emit(\"await:clientReorder\", awaitInfo);\n  } else {\n    out.flush(); // Flush everything up to this await instance\n    asyncOut = awaitInfo.out = out.beginAsync({\n      timeout: 0, // We will use our code for controlling timeout\n      name: name\n    });\n  }\n\n  var beforeRenderEmitted = false;\n\n  out.emit(\"await:begin\", awaitInfo);\n\n  function renderBody(err, data) {\n    if (awaitInfo.finished) {\n      return;\n    }\n\n    if (err) {\n      awaitInfo.error = err;\n    }\n\n    if (!beforeRenderEmitted) {\n      beforeRenderEmitted = true;\n      out.emit(\"await:beforeRender\", awaitInfo);\n    }\n\n    renderContents(err, data, input, asyncOut);\n\n    awaitInfo.finished = true;\n\n    if (clientReorder) {\n      asyncOut.end();\n      out.flush();\n    } else {\n      // When using client reordering we want to delay\n      // this event until after the code to move\n      // the async fragment into place has been written\n      let asyncLastOut = asyncOut.beginAsync(LAST_OPTIONS);\n      asyncOut.onLast(function () {\n        var oldWriter = asyncOut.writer;\n        // We swap out the writer so that writing will happen to our `asyncLastOut`\n        // even though we are still passing along the original `asyncOut`. We have\n        // to pass along the original `asyncOut` because that has contextual\n        // information (such as the rendered UI components)\n        asyncOut.writer = asyncLastOut.writer;\n        out.emit(\"await:finish\", awaitInfo);\n        asyncOut.writer = oldWriter;\n        asyncLastOut.end();\n        out.flush();\n      });\n\n      asyncOut.end();\n    }\n  }\n\n  asyncValue.___done(renderBody);\n};\n\nfunction renderContents(err, data, input, out) {\n  var resultRenderer = input.then && input.then.renderBody;\n  var errorRenderer = input.catch && input.catch.renderBody;\n\n  if (err) {\n    if (input.catch) {\n      if (errorRenderer) {\n        errorRenderer(out, err);\n      }\n    } else {\n      out.error(err);\n    }\n  } else {\n    if (resultRenderer) {\n      var renderBodyErr = safeRenderBody(resultRenderer, out, data);\n\n      if (renderBodyErr) {\n        return renderContents(renderBodyErr, data, input, out);\n      }\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["value"]
}
