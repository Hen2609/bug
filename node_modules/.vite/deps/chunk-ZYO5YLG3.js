import {
  require_fragment,
  require_vdom
} from "./chunk-O2ZL6YJ2.js";
import {
  require_helpers
} from "./chunk-BYPQ4JD2.js";
import {
  require_KeySequence
} from "./chunk-H4Y2AQYP.js";
import {
  require_event_delegation
} from "./chunk-FDEQ5SZB.js";
import {
  require_dom_data,
  require_index_browser
} from "./chunk-GSFJVMIM.js";
import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/marko/src/runtime/vdom/morphdom/specialElHandlers.js
var require_specialElHandlers = __commonJS({
  "node_modules/marko/src/runtime/vdom/morphdom/specialElHandlers.js"(exports, module) {
    function syncBooleanAttrProp(fromEl, toEl, name) {
      if (fromEl[name] !== toEl[name]) {
        fromEl[name] = toEl[name];
        if (fromEl[name]) {
          fromEl.setAttribute(name, "");
        } else {
          fromEl.removeAttribute(name, "");
        }
      }
    }
    function forEachOption(el, fn, i) {
      var curChild = el.___firstChild;
      while (curChild) {
        if (curChild.___nodeName === "option") {
          fn(curChild, ++i);
        } else {
          i = forEachOption(curChild, fn, i);
        }
        curChild = curChild.___nextSibling;
      }
      return i;
    }
    function SpecialElHandlers() {
    }
    SpecialElHandlers.prototype = {
      option: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, "selected");
      },
      button: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, "disabled");
      },
      input: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, "checked");
        syncBooleanAttrProp(fromEl, toEl, "disabled");
        if (fromEl.value != toEl.___value) {
          fromEl.value = toEl.___value;
        }
        if (fromEl.hasAttribute("value") && !toEl.___hasAttribute("value")) {
          fromEl.removeAttribute("value");
        }
      },
      textarea: function(fromEl, toEl) {
        if (toEl.___preserveTextAreaValue) {
          return;
        }
        var newValue = toEl.___value;
        if (fromEl.value != newValue) {
          fromEl.value = newValue;
        }
        var firstChild = fromEl.firstChild;
        if (firstChild) {
          var oldValue = firstChild.nodeValue;
          if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
            return;
          }
          firstChild.nodeValue = newValue;
        }
      },
      select: function(fromEl, toEl) {
        if (!toEl.___hasAttribute("multiple")) {
          var selected = 0;
          forEachOption(
            toEl,
            function(option, i) {
              if (option.___hasAttribute("selected")) {
                selected = i;
              }
            },
            -1
          );
          if (fromEl.selectedIndex !== selected) {
            fromEl.selectedIndex = selected;
          }
        }
      }
    };
    module.exports = new SpecialElHandlers();
  }
});

// node_modules/marko/src/runtime/vdom/morphdom/index.js
var require_morphdom = __commonJS({
  "node_modules/marko/src/runtime/vdom/morphdom/index.js"(exports, module) {
    "use strict";
    var specialElHandlers = require_specialElHandlers();
    var KeySequence = require_KeySequence();
    var componentsUtil = require_index_browser();
    var existingComponentLookup = componentsUtil.___componentLookup;
    var destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;
    var addComponentRootToKeyedElements = componentsUtil.___addComponentRootToKeyedElements;
    var normalizeComponentKey = componentsUtil.___normalizeComponentKey;
    var VElement = require_vdom().___VElement;
    var virtualizeElement = VElement.___virtualize;
    var morphAttrs = VElement.___morphAttrs;
    var eventDelegation = require_event_delegation();
    var fragment = require_fragment();
    var helpers = require_helpers();
    var domData = require_dom_data();
    var keysByDOMNode = domData.___keyByDOMNode;
    var componentByDOMNode = domData.___componentByDOMNode;
    var vElementByDOMNode = domData.___vElementByDOMNode;
    var detachedByDOMNode = domData.___detachedByDOMNode;
    var insertBefore = helpers.___insertBefore;
    var insertAfter = helpers.___insertAfter;
    var nextSibling = helpers.___nextSibling;
    var firstChild = helpers.___firstChild;
    var removeChild = helpers.___removeChild;
    var createFragmentNode = fragment.___createFragmentNode;
    var beginFragmentNode = fragment.___beginFragmentNode;
    var ELEMENT_NODE = 1;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;
    var COMPONENT_NODE = 2;
    var FRAGMENT_NODE = 12;
    var DOCTYPE_NODE = 10;
    function isAutoKey(key) {
      return key[0] !== "@";
    }
    function compareNodeNames(fromEl, toEl) {
      return fromEl.___nodeName === toEl.___nodeName;
    }
    function caseInsensitiveCompare(a, b) {
      return a.toLowerCase() === b.toLowerCase();
    }
    function onNodeAdded(node, componentsContext) {
      if (node.nodeType === ELEMENT_NODE) {
        eventDelegation.___handleNodeAttach(node, componentsContext);
      }
    }
    function morphdom(fromNode, toNode, host, componentsContext) {
      var globalComponentsContext;
      var isHydrate = false;
      var keySequences = /* @__PURE__ */ Object.create(null);
      if (componentsContext) {
        globalComponentsContext = componentsContext.___globalContext;
        isHydrate = globalComponentsContext.___isHydrate;
      }
      function insertVirtualNodeBefore(vNode, key, referenceEl, parentEl, ownerComponent, parentComponent) {
        var realNode = vNode.___actualize(host, parentEl.namespaceURI);
        insertBefore(realNode, referenceEl, parentEl);
        if (vNode.___nodeType === ELEMENT_NODE || vNode.___nodeType === FRAGMENT_NODE) {
          if (key) {
            keysByDOMNode.set(realNode, key);
            (isAutoKey(key) ? parentComponent : ownerComponent).___keyedElements[key] = realNode;
          }
          if (vNode.___nodeName !== "textarea") {
            morphChildren(realNode, vNode, parentComponent);
          }
          onNodeAdded(realNode, componentsContext);
        }
      }
      function insertVirtualComponentBefore(vComponent, referenceNode, referenceNodeParentEl, component, key, ownerComponent, parentComponent) {
        var rootNode = component.___rootNode = insertBefore(
          createFragmentNode(),
          referenceNode,
          referenceNodeParentEl
        );
        componentByDOMNode.set(rootNode, component);
        if (key && ownerComponent) {
          key = normalizeComponentKey(key, parentComponent.id);
          addComponentRootToKeyedElements(
            ownerComponent.___keyedElements,
            key,
            rootNode,
            component.id
          );
          keysByDOMNode.set(rootNode, key);
        }
        morphComponent(component, vComponent);
      }
      function morphComponent(component, vComponent) {
        morphChildren(component.___rootNode, vComponent, component);
      }
      var detachedNodes = [];
      function detachNode(node, parentNode, ownerComponent) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === FRAGMENT_NODE) {
          detachedNodes.push(node);
          detachedByDOMNode.set(node, ownerComponent || true);
        } else {
          destroyNodeRecursive(node);
          removeChild(node);
        }
      }
      function destroyComponent(component) {
        component.destroy();
      }
      function morphChildren(fromNode2, toNode2, parentComponent) {
        var curFromNodeChild = firstChild(fromNode2);
        var curToNodeChild = toNode2.___firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var curToNodeType;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        var matchingFromComponent;
        var curVFromNodeChild;
        var fromComponent;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.___nextSibling;
            curToNodeType = curToNodeChild.___nodeType;
            curToNodeKey = curToNodeChild.___key;
            if (curFromNodeChild && curFromNodeChild.nodeType === DOCTYPE_NODE) {
              curFromNodeChild = nextSibling(curFromNodeChild);
            }
            var ownerComponent = curToNodeChild.___ownerComponent || parentComponent;
            var referenceComponent;
            if (curToNodeType === COMPONENT_NODE) {
              var component = curToNodeChild.___component;
              if ((matchingFromComponent = existingComponentLookup[component.id]) === void 0) {
                if (isHydrate === true) {
                  var rootNode = beginFragmentNode(curFromNodeChild, fromNode2);
                  component.___rootNode = rootNode;
                  componentByDOMNode.set(rootNode, component);
                  if (ownerComponent && curToNodeKey) {
                    curToNodeKey = normalizeComponentKey(
                      curToNodeKey,
                      parentComponent.id
                    );
                    addComponentRootToKeyedElements(
                      ownerComponent.___keyedElements,
                      curToNodeKey,
                      rootNode,
                      component.id
                    );
                    keysByDOMNode.set(rootNode, curToNodeKey);
                  }
                  morphComponent(component, curToNodeChild);
                  curFromNodeChild = nextSibling(rootNode);
                } else {
                  insertVirtualComponentBefore(
                    curToNodeChild,
                    curFromNodeChild,
                    fromNode2,
                    component,
                    curToNodeKey,
                    ownerComponent,
                    parentComponent
                  );
                }
              } else {
                if (matchingFromComponent.___rootNode !== curFromNodeChild) {
                  if (curFromNodeChild && (fromComponent = componentByDOMNode.get(curFromNodeChild)) && globalComponentsContext.___renderedComponentsById[fromComponent.id] === void 0) {
                    curFromNodeChild = nextSibling(fromComponent.___rootNode);
                    destroyComponent(fromComponent);
                    continue;
                  }
                  insertBefore(
                    matchingFromComponent.___rootNode,
                    curFromNodeChild,
                    fromNode2
                  );
                } else {
                  curFromNodeChild = curFromNodeChild && nextSibling(curFromNodeChild);
                }
                if (!curToNodeChild.___preserve) {
                  morphComponent(component, curToNodeChild);
                }
              }
              curToNodeChild = toNextSibling;
              continue;
            } else if (curToNodeKey) {
              curVFromNodeChild = void 0;
              curFromNodeKey = void 0;
              var curToNodeKeyOriginal = curToNodeKey;
              if (isAutoKey(curToNodeKey)) {
                if (ownerComponent !== parentComponent) {
                  curToNodeKey += ":" + ownerComponent.id;
                }
                referenceComponent = parentComponent;
              } else {
                referenceComponent = ownerComponent;
              }
              curToNodeKey = (keySequences[referenceComponent.id] || (keySequences[referenceComponent.id] = new KeySequence())).___nextKey(curToNodeKey);
              if (curFromNodeChild) {
                curFromNodeKey = keysByDOMNode.get(curFromNodeChild);
                curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);
                fromNextSibling = nextSibling(curFromNodeChild);
              }
              if (curFromNodeKey === curToNodeKey) {
                if (!curToNodeChild.___preserve) {
                  if (compareNodeNames(curToNodeChild, curVFromNodeChild)) {
                    morphEl(
                      curFromNodeChild,
                      curVFromNodeChild,
                      curToNodeChild,
                      parentComponent
                    );
                  } else {
                    detachNode(curFromNodeChild, fromNode2, ownerComponent);
                    insertVirtualNodeBefore(
                      curToNodeChild,
                      curToNodeKey,
                      curFromNodeChild,
                      fromNode2,
                      ownerComponent,
                      parentComponent
                    );
                  }
                }
              } else {
                matchingFromEl = referenceComponent.___keyedElements[curToNodeKey];
                if (matchingFromEl === void 0 || matchingFromEl === curFromNodeChild) {
                  if (isHydrate === true && curFromNodeChild) {
                    if (curFromNodeChild.nodeType === ELEMENT_NODE && (curToNodeChild.___preserve || caseInsensitiveCompare(
                      curFromNodeChild.nodeName,
                      curToNodeChild.___nodeName || ""
                    ))) {
                      curVFromNodeChild = virtualizeElement(curFromNodeChild);
                      curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;
                      keysByDOMNode.set(curFromNodeChild, curToNodeKey);
                      referenceComponent.___keyedElements[curToNodeKey] = curFromNodeChild;
                      if (curToNodeChild.___preserve) {
                        vElementByDOMNode.set(curFromNodeChild, curVFromNodeChild);
                      } else {
                        morphEl(
                          curFromNodeChild,
                          curVFromNodeChild,
                          curToNodeChild,
                          parentComponent
                        );
                      }
                      curToNodeChild = toNextSibling;
                      curFromNodeChild = fromNextSibling;
                      continue;
                    } else if (curToNodeChild.___nodeType === FRAGMENT_NODE && curFromNodeChild.nodeType === COMMENT_NODE) {
                      var content = curFromNodeChild.nodeValue;
                      if (content == "F#" + curToNodeKeyOriginal) {
                        var endNode = curFromNodeChild.nextSibling;
                        var depth = 0;
                        var nodeValue;
                        while (true) {
                          if (endNode.nodeType === COMMENT_NODE) {
                            nodeValue = endNode.nodeValue;
                            if (nodeValue === "F/") {
                              if (depth === 0) {
                                break;
                              } else {
                                depth--;
                              }
                            } else if (nodeValue.indexOf("F#") === 0) {
                              depth++;
                            }
                          }
                          endNode = endNode.nextSibling;
                        }
                        var fragment2 = createFragmentNode(
                          curFromNodeChild,
                          endNode.nextSibling,
                          fromNode2
                        );
                        keysByDOMNode.set(fragment2, curToNodeKey);
                        vElementByDOMNode.set(fragment2, curToNodeChild);
                        referenceComponent.___keyedElements[curToNodeKey] = fragment2;
                        removeChild(curFromNodeChild);
                        removeChild(endNode);
                        if (!curToNodeChild.___preserve) {
                          morphChildren(fragment2, curToNodeChild, parentComponent);
                        }
                        curToNodeChild = toNextSibling;
                        curFromNodeChild = fragment2.nextSibling;
                        continue;
                      }
                    }
                  }
                  insertVirtualNodeBefore(
                    curToNodeChild,
                    curToNodeKey,
                    curFromNodeChild,
                    fromNode2,
                    ownerComponent,
                    parentComponent
                  );
                  fromNextSibling = curFromNodeChild;
                } else {
                  if (detachedByDOMNode.get(matchingFromEl) !== void 0) {
                    detachedByDOMNode.set(matchingFromEl, void 0);
                  }
                  if (!curToNodeChild.___preserve) {
                    curVFromNodeChild = vElementByDOMNode.get(matchingFromEl);
                    if (compareNodeNames(curVFromNodeChild, curToNodeChild)) {
                      if (fromNextSibling === matchingFromEl) {
                        if (toNextSibling && toNextSibling.___key === curFromNodeKey) {
                          fromNextSibling = curFromNodeChild;
                          insertBefore(matchingFromEl, curFromNodeChild, fromNode2);
                        } else {
                          fromNextSibling = nextSibling(fromNextSibling);
                          if (curFromNodeChild) {
                            detachNode(curFromNodeChild, fromNode2, ownerComponent);
                          }
                        }
                      } else {
                        insertAfter(matchingFromEl, curFromNodeChild, fromNode2);
                        if (curFromNodeChild) {
                          detachNode(curFromNodeChild, fromNode2, ownerComponent);
                        }
                      }
                      morphEl(
                        matchingFromEl,
                        curVFromNodeChild,
                        curToNodeChild,
                        parentComponent
                      );
                    } else {
                      insertVirtualNodeBefore(
                        curToNodeChild,
                        curToNodeKey,
                        curFromNodeChild,
                        fromNode2,
                        ownerComponent,
                        parentComponent
                      );
                      detachNode(matchingFromEl, fromNode2, ownerComponent);
                    }
                  } else {
                    insertBefore(matchingFromEl, curFromNodeChild, fromNode2);
                    fromNextSibling = curFromNodeChild;
                  }
                }
              }
              curToNodeChild = toNextSibling;
              curFromNodeChild = fromNextSibling;
              continue;
            }
            while (curFromNodeChild) {
              fromNextSibling = nextSibling(curFromNodeChild);
              if (fromComponent = componentByDOMNode.get(curFromNodeChild)) {
                curFromNodeChild = fromNextSibling;
                if (!globalComponentsContext.___renderedComponentsById[fromComponent.id]) {
                  destroyComponent(fromComponent);
                }
                continue;
              }
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);
                  if (curVFromNodeChild === void 0) {
                    if (isHydrate === true) {
                      curVFromNodeChild = virtualizeElement(curFromNodeChild);
                      if (caseInsensitiveCompare(
                        curVFromNodeChild.___nodeName,
                        curToNodeChild.___nodeName
                      )) {
                        curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;
                      }
                    } else {
                      curFromNodeChild = fromNextSibling;
                      continue;
                    }
                  } else if (curFromNodeKey = curVFromNodeChild.___key) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curVFromNodeChild, curToNodeChild) === true;
                  if (isCompatible === true) {
                    morphEl(
                      curFromNodeChild,
                      curVFromNodeChild,
                      curToNodeChild,
                      parentComponent
                    );
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType === COMMENT_NODE) {
                  isCompatible = true;
                  if (isHydrate === true && toNextSibling && curFromNodeType === TEXT_NODE && toNextSibling.___nodeType === TEXT_NODE) {
                    fromNextSibling = curFromNodeChild.splitText(
                      curToNodeChild.___nodeValue.length
                    );
                  }
                  if (curFromNodeChild.nodeValue !== curToNodeChild.___nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.___nodeValue;
                  }
                }
              }
              if (isCompatible === true) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              detachNode(curFromNodeChild, fromNode2, ownerComponent);
              curFromNodeChild = fromNextSibling;
            }
            insertVirtualNodeBefore(
              curToNodeChild,
              curToNodeKey,
              curFromNodeChild,
              fromNode2,
              ownerComponent,
              parentComponent
            );
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        if (fromNode2.___finishFragment) {
          fromNode2.___finishFragment(curFromNodeChild);
        } else {
          var fragmentBoundary = fromNode2.nodeType === FRAGMENT_NODE ? fromNode2.endNode : null;
          while (curFromNodeChild && curFromNodeChild !== fragmentBoundary) {
            fromNextSibling = nextSibling(curFromNodeChild);
            if (fromComponent = componentByDOMNode.get(curFromNodeChild)) {
              curFromNodeChild = fromNextSibling;
              if (!globalComponentsContext.___renderedComponentsById[fromComponent.id]) {
                destroyComponent(fromComponent);
              }
              continue;
            }
            curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);
            curFromNodeKey = keysByDOMNode.get(fromNode2);
            if (!curFromNodeKey || isAutoKey(curFromNodeKey)) {
              referenceComponent = parentComponent;
            } else {
              referenceComponent = curVFromNodeChild && curVFromNodeChild.___ownerComponent;
            }
            detachNode(curFromNodeChild, fromNode2, referenceComponent);
            curFromNodeChild = fromNextSibling;
          }
        }
      }
      function morphEl(fromEl, vFromEl, toEl, parentComponent) {
        var nodeName = toEl.___nodeName;
        var constId = toEl.___constId;
        if (constId !== void 0 && vFromEl.___constId === constId) {
          return;
        }
        morphAttrs(fromEl, vFromEl, toEl);
        if (toEl.___preserveBody) {
          return;
        }
        if (nodeName !== "textarea") {
          morphChildren(fromEl, toEl, parentComponent);
        }
        var specialElHandler = specialElHandlers[nodeName];
        if (specialElHandler !== void 0) {
          specialElHandler(fromEl, toEl);
        }
      }
      if ("MARKO_DEBUG") {
        componentsUtil.___stopDOMManipulationWarning(host);
      }
      morphChildren(fromNode, toNode, toNode.___component);
      detachedNodes.forEach(function(node) {
        var detachedFromComponent = detachedByDOMNode.get(node);
        if (detachedFromComponent !== void 0) {
          detachedByDOMNode.set(node, void 0);
          var componentToDestroy = componentByDOMNode.get(node);
          if (componentToDestroy) {
            componentToDestroy.destroy();
          } else if (node.parentNode) {
            destroyNodeRecursive(
              node,
              detachedFromComponent !== true && detachedFromComponent
            );
            if (eventDelegation.___handleNodeDetach(node) != false) {
              removeChild(node);
            }
          }
        }
      });
      if ("MARKO_DEBUG") {
        componentsUtil.___startDOMManipulationWarning(host);
      }
    }
    module.exports = morphdom;
  }
});

export {
  require_morphdom
};
//# sourceMappingURL=chunk-ZYO5YLG3.js.map
