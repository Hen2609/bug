import {
  require_queueMicrotask
} from "./chunk-XSOBGFXV.js";
import {
  require_defineComponent
} from "./chunk-3MO5ZOMD.js";
import {
  require_fragment
} from "./chunk-O2ZL6YJ2.js";
import {
  require_ComponentDef,
  require_constants
} from "./chunk-CLI2JG2L.js";
import {
  require_ComponentsContext
} from "./chunk-EOID6AGX.js";
import {
  require_complain
} from "./chunk-BXPA54VP.js";
import {
  require_event_delegation
} from "./chunk-FDEQ5SZB.js";
import {
  require_dom_data,
  require_index_browser
} from "./chunk-GSFJVMIM.js";
import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/warp10/src/finalize.js
var require_finalize = __commonJS({
  "node_modules/warp10/src/finalize.js"(exports2, module2) {
    var constants = require_constants();
    var isArray = Array.isArray;
    function resolve(object, path, len) {
      var current = object;
      for (var i = 0; i < len; i++) {
        current = current[path[i]];
      }
      return current;
    }
    function resolveType(info) {
      if (info.type === "Date") {
        return new Date(info.value);
      } else if (info.type === "NOOP") {
        return constants.NOOP;
      } else {
        throw new Error("Bad type");
      }
    }
    module2.exports = function finalize(outer) {
      if (!outer) {
        return outer;
      }
      var assignments = outer.$$;
      if (assignments) {
        var object = outer.o;
        var len;
        if (assignments && (len = assignments.length)) {
          for (var i = 0; i < len; i++) {
            var assignment = assignments[i];
            var rhs = assignment.r;
            var rhsValue;
            if (isArray(rhs)) {
              rhsValue = resolve(object, rhs, rhs.length);
            } else {
              rhsValue = resolveType(rhs);
            }
            var lhs = assignment.l;
            var lhsLast = lhs.length - 1;
            if (lhsLast === -1) {
              object = outer.o = rhsValue;
              break;
            } else {
              var lhsParent = resolve(object, lhs, lhsLast);
              lhsParent[lhs[lhsLast]] = rhsValue;
            }
          }
        }
        assignments.length = 0;
        return object == null ? null : object;
      } else {
        return outer;
      }
    };
  }
});

// node_modules/warp10/finalize.js
var require_finalize2 = __commonJS({
  "node_modules/warp10/finalize.js"(exports2, module2) {
    module2.exports = require_finalize();
  }
});

// node_modules/marko/src/runtime/components/init-components/index-browser.js
var require_index_browser2 = __commonJS({
  "node_modules/marko/src/runtime/components/init-components/index-browser.js"(exports2) {
    "use strict";
    var complain2 = require_complain();
    var warp10Finalize = require_finalize2();
    var eventDelegation = require_event_delegation();
    var win = window;
    var createFragmentNode = require_fragment().___createFragmentNode;
    var componentsUtil = require_index_browser();
    var componentLookup = componentsUtil.___componentLookup;
    var addComponentRootToKeyedElements = componentsUtil.___addComponentRootToKeyedElements;
    var ComponentDef = require_ComponentDef();
    var registry = require_index_browser4();
    var domData = require_dom_data();
    var keyedElementsByComponentId = domData.___ssrKeyedElementsByComponentId;
    var componentsByDOMNode = domData.___componentByDOMNode;
    var serverComponentRootNodes = {};
    var serverRenderedMeta = {};
    var DEFAULT_RUNTIME_ID = "M";
    var FLAG_WILL_RERENDER_IN_BROWSER = 1;
    var deferredDefs;
    function indexServerComponentBoundaries(node, runtimeId, stack) {
      var componentId;
      var ownerId;
      var ownerComponent;
      var keyedElements;
      var nextSibling;
      var runtimeLength = runtimeId.length;
      stack = stack || [];
      node = node.firstChild;
      while (node) {
        nextSibling = node.nextSibling;
        if (node.nodeType === 8) {
          var commentValue = node.nodeValue;
          if (commentValue.slice(0, runtimeLength) === runtimeId) {
            var firstChar = commentValue[runtimeLength];
            if (firstChar === "^" || firstChar === "#") {
              stack.push(node);
            } else if (firstChar === "/") {
              var endNode = node;
              var startNode = stack.pop();
              var rootNode;
              if (startNode.parentNode === endNode.parentNode) {
                rootNode = createFragmentNode(startNode.nextSibling, endNode);
              } else {
                rootNode = createFragmentNode(
                  endNode.parentNode.firstChild,
                  endNode
                );
              }
              componentId = startNode.nodeValue.substring(runtimeLength + 1);
              firstChar = startNode.nodeValue[runtimeLength];
              if (firstChar === "^") {
                var parts = componentId.split(/ /g);
                var key = parts[2];
                ownerId = parts[1];
                componentId = parts[0];
                if (ownerComponent = componentLookup[ownerId]) {
                  keyedElements = ownerComponent.___keyedElements;
                } else {
                  keyedElements = keyedElementsByComponentId[ownerId] || (keyedElementsByComponentId[ownerId] = {});
                }
                addComponentRootToKeyedElements(
                  keyedElements,
                  key,
                  rootNode,
                  componentId
                );
              }
              serverComponentRootNodes[componentId] = rootNode;
              startNode.parentNode.removeChild(startNode);
              endNode.parentNode.removeChild(endNode);
            }
          }
        } else if (node.nodeType === 1) {
          var markoKey = node.getAttribute("data-marko-key");
          var markoProps = componentsUtil.___getMarkoPropsFromEl(node);
          if (markoKey) {
            var separatorIndex = markoKey.indexOf(" ");
            ownerId = markoKey.substring(separatorIndex + 1);
            markoKey = markoKey.substring(0, separatorIndex);
            if (ownerComponent = componentLookup[ownerId]) {
              keyedElements = ownerComponent.___keyedElements;
            } else {
              keyedElements = keyedElementsByComponentId[ownerId] || (keyedElementsByComponentId[ownerId] = {});
            }
            keyedElements[markoKey] = node;
          }
          if (markoProps) {
            Object.keys(markoProps).forEach(function(key2) {
              if (key2.slice(0, 2) === "on") {
                eventDelegation.___addDelegatedEventHandler(key2.slice(2));
              }
            });
          }
          indexServerComponentBoundaries(node, runtimeId, stack);
        }
        node = nextSibling;
      }
    }
    function invokeComponentEventHandler(component, targetMethodName, args) {
      var method = component[targetMethodName];
      if (!method) {
        throw Error("Method not found: " + targetMethodName);
      }
      method.apply(component, args);
    }
    function addEventListenerHelper(el, eventType, isOnce, listener) {
      var eventListener = listener;
      if (isOnce) {
        eventListener = function(event) {
          listener(event);
          el.removeEventListener(eventType, eventListener);
        };
      }
      el.addEventListener(eventType, eventListener, false);
      return function remove() {
        el.removeEventListener(eventType, eventListener);
      };
    }
    function addDOMEventListeners(component, el, eventType, targetMethodName, isOnce, extraArgs, handles) {
      var removeListener = addEventListenerHelper(
        el,
        eventType,
        isOnce,
        function(event) {
          var args = [event, el];
          if (extraArgs) {
            args = extraArgs.concat(args);
          }
          invokeComponentEventHandler(component, targetMethodName, args);
        }
      );
      handles.push(removeListener);
    }
    function initComponent(componentDef, host) {
      var component = componentDef.___component;
      component.___reset();
      component.___host = host;
      var isExisting = componentDef.___isExisting;
      if (isExisting) {
        component.___removeDOMEventListeners();
      }
      var domEvents = componentDef.___domEvents;
      if (domEvents) {
        var eventListenerHandles = [];
        domEvents.forEach(function(domEventArgs) {
          var eventType = domEventArgs[0];
          var targetMethodName = domEventArgs[1];
          var eventEl = component.___keyedElements[domEventArgs[2]];
          var isOnce = domEventArgs[3];
          var extraArgs = domEventArgs[4];
          addDOMEventListeners(
            component,
            eventEl,
            eventType,
            targetMethodName,
            isOnce,
            extraArgs,
            eventListenerHandles
          );
        });
        if (eventListenerHandles.length) {
          component.___domEventListenerHandles = eventListenerHandles;
        }
      }
      if (component.___mounted) {
        component.___emitUpdate();
      } else {
        component.___mounted = true;
        component.___emitMount();
      }
    }
    function initClientRendered(componentDefs, host) {
      if (!host)
        host = document;
      eventDelegation.___init(host);
      var len = componentDefs.length;
      var componentDef;
      var i;
      for (i = len; i--; ) {
        componentDef = componentDefs[i];
        trackComponent(componentDef);
      }
      for (i = len; i--; ) {
        componentDef = componentDefs[i];
        initComponent(componentDef, host);
      }
    }
    function initServerRendered(renderedComponents, host) {
      var type = typeof renderedComponents;
      var globalKey = "$";
      var runtimeId;
      if (type !== "object") {
        if (type === "string") {
          runtimeId = renderedComponents;
          globalKey += runtimeId + "_C";
        } else {
          globalKey += (runtimeId = DEFAULT_RUNTIME_ID) + "C";
        }
        renderedComponents = win[globalKey];
        if ("MARKO_DEBUG") {
          if (renderedComponents && renderedComponents.i !== void 0 && renderedComponents.i !== componentsUtil.___runtimeId) {
            console.warn(
              "Multiple instances of Marko have attached to the same runtime id. This could mean that more than one copy of Marko is loaded on the page, or that the script containing Marko has executed more than once."
            );
          }
        }
        var fakeArray = win[globalKey] = {
          r: runtimeId,
          concat: initServerRendered
        };
        if ("MARKO_DEBUG") {
          fakeArray.i = componentsUtil.___runtimeId;
        }
        if (renderedComponents && renderedComponents.forEach) {
          renderedComponents.forEach(function(renderedComponent) {
            fakeArray.concat(renderedComponent);
          });
        }
        return fakeArray;
      }
      var isFromSerializedGlobals = this.concat === initServerRendered;
      renderedComponents = warp10Finalize(renderedComponents);
      if (isFromSerializedGlobals) {
        runtimeId = this.r;
        host = document;
      } else {
        runtimeId = renderedComponents.r || DEFAULT_RUNTIME_ID;
        if (!host)
          host = document;
        if ("MARKO_DEBUG") {
          complain2(
            "Passing serialized data to `require('marko/components).init` is deprecated. Instead set '$global.runtimeId' and provide the 'runtimeId' option to your Marko bundler plugin."
          );
        }
      }
      if ("MARKO_DEBUG") {
        if (host !== document) {
          complain2(
            "Passing a document other than the current document to `require('marko/components).init` is deprecated."
          );
        }
      }
      var prefix = renderedComponents.p || "";
      var meta = serverRenderedMeta[prefix];
      var isLast = renderedComponents.l;
      if (meta) {
        if (isLast) {
          delete serverRenderedMeta[prefix];
        }
      } else {
        meta = {};
        if (!isLast) {
          serverRenderedMeta[prefix] = meta;
        }
      }
      indexServerComponentBoundaries(host, runtimeId);
      eventDelegation.___init(host);
      if (renderedComponents.g) {
        meta.___globals = renderedComponents.g;
      }
      if (renderedComponents.t) {
        meta.___types = meta.___types ? meta.___types.concat(renderedComponents.t) : renderedComponents.t;
      }
      (renderedComponents.w || []).map(function(componentDef) {
        var typeName2 = meta.___types[componentDef[1]];
        return registry.___isRegistered(typeName2) ? tryHydrateComponent(componentDef, meta, host, runtimeId) : registry.___addPendingDef(
          componentDef,
          typeName2,
          meta,
          host,
          runtimeId
        );
      }).reverse().forEach(tryInvoke);
      return this;
    }
    function tryHydrateComponent(rawDef, meta, host, runtimeId) {
      var componentDef = ComponentDef.___deserialize(
        rawDef,
        meta.___types,
        meta.___globals,
        registry
      );
      var mount = hydrateComponentAndGetMount(componentDef, host);
      if (!mount) {
        if (deferredDefs) {
          deferredDefs.push(componentDef);
        } else {
          deferredDefs = [componentDef];
          document.addEventListener("DOMContentLoaded", function() {
            indexServerComponentBoundaries(host, runtimeId);
            deferredDefs.map(function(componentDef2) {
              return hydrateComponentAndGetMount(componentDef2, host);
            }).reverse().forEach(tryInvoke);
            deferredDefs = void 0;
          });
        }
      }
      return mount;
    }
    function hydrateComponentAndGetMount(componentDef, host) {
      var componentId = componentDef.id;
      var component = componentDef.___component;
      var rootNode = serverComponentRootNodes[componentId];
      var renderResult;
      if (rootNode) {
        delete serverComponentRootNodes[componentId];
        component.___rootNode = rootNode;
        componentsByDOMNode.set(rootNode, component);
        if (componentDef.___flags & FLAG_WILL_RERENDER_IN_BROWSER) {
          component.___host = host;
          renderResult = component.___rerender(component.___input, true);
          trackComponent(componentDef);
          return function mount() {
            renderResult.afterInsert(host);
          };
        } else {
          trackComponent(componentDef);
        }
        return function mount() {
          initComponent(componentDef, host);
        };
      }
    }
    function trackComponent(componentDef) {
      var component = componentDef.___component;
      if (component) {
        componentLookup[component.id] = component;
      }
    }
    function tryInvoke(fn) {
      if (fn)
        fn();
    }
    exports2.___initClientRendered = initClientRendered;
    exports2.___initServerRendered = initServerRendered;
    exports2.___tryHydrateComponent = tryHydrateComponent;
  }
});

// node_modules/marko/src/runtime/components/entry/index-browser.js
var require_index_browser3 = __commonJS({
  "node_modules/marko/src/runtime/components/entry/index-browser.js"(exports2) {
    var initComponents2 = require_index_browser2();
    require_ComponentsContext().___initClientRendered = initComponents2.___initClientRendered;
    exports2.getComponentForEl = require_index_browser().___getComponentForEl;
    exports2.init = window.$initComponents = initComponents2.___initServerRendered;
    var registry = require_index_browser4();
    exports2.register = function(id, component) {
      registry.r(id, function() {
        return component;
      });
    };
  }
});

// node_modules/marko/src/runtime/components/registry/index-browser.js
var require_index_browser4 = __commonJS({
  "node_modules/marko/src/runtime/components/registry/index-browser.js"(exports, module) {
    var complain = require_complain();
    var queueMicrotask = require_queueMicrotask();
    var defineComponent = require_defineComponent();
    var initComponents = require_index_browser2();
    require_index_browser3();
    var registered = {};
    var loaded = {};
    var componentTypes = {};
    var pendingDefs;
    function register(type, def) {
      var pendingForType;
      if (pendingDefs) {
        pendingForType = pendingDefs[type];
      }
      registered[type] = def;
      delete loaded[type];
      delete componentTypes[type];
      if (pendingForType) {
        delete pendingDefs[type];
        queueMicrotask(function() {
          pendingForType.forEach(function(args) {
            initComponents.___tryHydrateComponent(
              args[0],
              args[1],
              args[2],
              args[3]
            )();
          });
        });
      }
      return type;
    }
    function addPendingDef(def, type, meta, host, runtimeId) {
      if (!pendingDefs) {
        pendingDefs = {};
        if ("MARKO_DEBUG") {
          document.addEventListener("load", function() {
            var pendingComponentIds = Object.keys(pendingDefs);
            if (pendingComponentIds.length) {
              complain(
                "Marko templates were never loaded for: " + pendingComponentIds
              );
            }
          });
        }
      }
      (pendingDefs[type] = pendingDefs[type] || []).push([
        def,
        meta,
        host,
        runtimeId
      ]);
    }
    function isRegistered(type) {
      return Boolean(registered[type]);
    }
    function load(typeName2) {
      var target = loaded[typeName2];
      if (!target) {
        target = registered[typeName2];
        if (target) {
          target = target();
        }
        if (!target) {
          throw Error("Component not found: " + typeName2);
        }
        loaded[typeName2] = target;
      }
      return target;
    }
    function getComponentClass(typeName) {
      var ComponentClass = componentTypes[typeName];
      if (ComponentClass) {
        return ComponentClass;
      }
      ComponentClass = load(typeName);
      ComponentClass = ComponentClass.Component || ComponentClass;
      if (!ComponentClass.___isComponent) {
        ComponentClass = defineComponent(ComponentClass, ComponentClass.renderer);
      }
      ComponentClass.prototype.___type = typeName;
      if ("MARKO_DEBUG") {
        var classNameMatch = /\/([^/]+?)(?:\/index|\/template|)(?:\.marko|\.component(?:-browser)?|)$/.exec(
          typeName
        );
        var className = classNameMatch ? classNameMatch[1] : "AnonymousComponent";
        className = className.replace(/-(.)/g, function(g) {
          return g[1].toUpperCase();
        });
        className = className.replace(/\$\d+\.\d+\.\d+$/, "").replace(/^[^a-z$_]/i, "_$&").replace(/[^0-9a-z$_]+/gi, "_");
        className = className[0].toUpperCase() + className.slice(1);
        try {
          var OldComponentClass = ComponentClass;
          eval(
            "ComponentClass = function " + className + "(id, doc) { OldComponentClass.call(this, id, doc); }"
          );
          ComponentClass.prototype = OldComponentClass.prototype;
        } catch (e) {
        }
      }
      componentTypes[typeName] = ComponentClass;
      return ComponentClass;
    }
    function createComponent(typeName2, id) {
      var ComponentClass2 = getComponentClass(typeName2);
      return new ComponentClass2(id);
    }
    exports.r = register;
    exports.___getComponentClass = getComponentClass;
    exports.___createComponent = createComponent;
    exports.___isRegistered = isRegistered;
    exports.___addPendingDef = addPendingDef;
  }
});

export {
  require_index_browser4 as require_index_browser,
  require_index_browser3 as require_index_browser2
};
//# sourceMappingURL=chunk-DOJGUN4M.js.map
