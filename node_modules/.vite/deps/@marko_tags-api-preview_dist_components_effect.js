import {
  __commonJS,
  __toESM
} from "./chunk-FDIEHWGR.js";
import "./chunk-TWLJ45QX.js";

// node_modules/@marko/tags-api-preview/dist/chunk-5WRUZCBU.mjs
var require_patch_lifecycle = __commonJS({
  "src/util/patch-lifecycle.ts"(exports, module) {
    var extensionsKey = Symbol();
    function addMethods(proto, methods) {
      for (const name in methods) {
        proto[name] = callBoth(proto[name], methods[name]);
      }
    }
    function callBoth(a, b) {
      if (a) {
        return function() {
          a.call(this);
          b.call(this);
        };
      }
      return b;
    }
    module.exports = function(component, methods) {
      const proto = component.__proto__;
      const extensions = proto[extensionsKey];
      if (extensions) {
        if (!extensions.has(methods)) {
          extensions.add(methods);
          addMethods(proto, methods);
          return true;
        }
      } else {
        proto[extensionsKey] = /* @__PURE__ */ new Set([methods]);
        addMethods(proto, methods);
        return true;
      }
      return false;
    };
  }
});

// node_modules/@marko/tags-api-preview/dist/components/effect/index.mjs
var require_effect = __commonJS({
  "src/components/effect/index.ts"(exports, module) {
    var import_patch_lifecycle = __toESM(require_patch_lifecycle());
    var metaKey = Symbol();
    var indexKey = Symbol();
    var lifecycleMethods = {
      onMount: runEffects,
      onUpdate: runEffects,
      onDestroy: runCleanups
    };
    function runEffects() {
      const meta = this[metaKey];
      if (meta) {
        this[indexKey] = 0;
        for (let i = 0; i < meta.length; i += 3) {
          if (meta[i]) {
            const fn = meta[i + 1];
            meta[i] = 0;
            if (fn) {
              meta[i + 2] = fn();
            }
          }
        }
      }
    }
    function runCleanups() {
      const meta = this[metaKey];
      if (meta) {
        for (let i = 2; i < meta.length; i += 3) {
          const cleanup = meta[i];
          cleanup && cleanup();
        }
      }
    }
    module.exports = function(component, fn) {
      const meta = component[metaKey];
      const index = component[indexKey];
      if (meta) {
        if (index === void 0) {
          meta.push(1, fn, 0);
        } else {
          component[indexKey] += 3;
          if (meta[index + 1] !== fn) {
            const cleanup = meta[index + 2];
            meta[index] = 1;
            meta[index + 1] = fn;
            if (cleanup) {
              cleanup();
              meta[index + 2] = 0;
            }
          }
        }
      } else {
        (0, import_patch_lifecycle.default)(component, lifecycleMethods);
        component[metaKey] = [1, fn, 0];
      }
    };
  }
});
var effect_default = require_effect();
export {
  effect_default as default
};
//# sourceMappingURL=@marko_tags-api-preview_dist_components_effect.js.map
