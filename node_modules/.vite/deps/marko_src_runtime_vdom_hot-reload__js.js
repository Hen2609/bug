import {
  require_vdom
} from "./chunk-HSNFP6IY.js";
import "./chunk-KOHG6577.js";
import "./chunk-DOCKNWKO.js";
import "./chunk-ZYLZHFSQ.js";
import {
  require_index_browser as require_index_browser2
} from "./chunk-DOJGUN4M.js";
import {
  require_queueMicrotask
} from "./chunk-XSOBGFXV.js";
import {
  require_update_manager
} from "./chunk-3MO5ZOMD.js";
import "./chunk-ZYO5YLG3.js";
import "./chunk-O2ZL6YJ2.js";
import "./chunk-DNVSKMP5.js";
import "./chunk-XFSNMVI3.js";
import "./chunk-FBABJUQR.js";
import "./chunk-BYPQ4JD2.js";
import "./chunk-3UWSHLBX.js";
import "./chunk-3EZRPHIR.js";
import "./chunk-CLI2JG2L.js";
import "./chunk-EOID6AGX.js";
import "./chunk-H4Y2AQYP.js";
import "./chunk-BXPA54VP.js";
import "./chunk-7ZAMFXOE.js";
import "./chunk-FDEQ5SZB.js";
import {
  require_index_browser
} from "./chunk-GSFJVMIM.js";
import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/marko/src/runtime/vdom/hot-reload.js
var require_hot_reload = __commonJS({
  "node_modules/marko/src/runtime/vdom/hot-reload.js"(exports, module) {
    var runtime = require_vdom();
    var queueMicrotask = require_queueMicrotask();
    var util = require_index_browser();
    var registry = require_index_browser2();
    var updateManager = require_update_manager();
    var createTemplate = runtime.t;
    var createComponent = registry.___createComponent;
    var registered = {};
    var queue;
    runtime.t = function(typeName) {
      if (registered[typeName]) {
        return registered[typeName];
      }
      var renderFn;
      var template = registered[typeName] = createTemplate(typeName);
      var instances = template.___instances = [];
      Object.defineProperty(template, "_", {
        get: function() {
          return renderFn && proxyRenderer;
        },
        set: function(v) {
          renderFn = v;
          if (instances.length) {
            if (!queue) {
              queue = [];
              queueMicrotask(batchUpdate);
            }
            queue.push(function() {
              var newProto = registry.___getComponentClass(typeName).prototype;
              instances.forEach(function(instance) {
                if (hasLifecycleChanged(instance.__proto__, newProto)) {
                  var startNode = instance.___rootNode.startNode;
                  var endNode = instance.___rootNode.endNode;
                  var parentNode = startNode.parentNode;
                  var curNode;
                  instance.___hmrDestroyed = true;
                  instance.___emitDestroy();
                  instance.___removeDOMEventListeners();
                  if (instance.___subscriptions) {
                    instance.___subscriptions.removeAllListeners();
                    instance.___subscriptions = null;
                  }
                  while ((curNode = startNode.nextSibling) !== endNode) {
                    util.___destroyNodeRecursive(curNode);
                    parentNode.removeChild(curNode);
                  }
                  instance.___hmrDestroyed = false;
                  instance.___mounted = false;
                }
                instance.__proto__ = newProto;
                instance.___rerender(instance.___input, false).afterInsert(instance.___host);
              });
            });
          }
        }
      });
      return template;
      function proxyRenderer() {
        return renderFn.apply(this, arguments);
      }
    };
    registry.___createComponent = function(typeName, id) {
      var template = registered[typeName];
      var instance = createComponent(typeName, id);
      if (template) {
        var instances = template.___instances;
        instances.push(instance);
        instance.once("destroy", function() {
          if (!instance.___hmrDestroyed) {
            instances.splice(1, instances.indexOf(instance));
          }
        });
      }
      return instance;
    };
    function hasLifecycleChanged(oldProto, newProto) {
      return hasMethodChanged("onCreate") || hasMethodChanged("onInput") || hasMethodChanged("onRender") || hasMethodChanged("onMount");
      function hasMethodChanged(method) {
        return (oldProto[method] && oldProto[method].toString()) !== (newProto[method] && newProto[method].toString());
      }
    }
    function batchUpdate() {
      updateManager.___batchUpdate(function() {
        var pending = queue;
        queue = void 0;
        for (var i = 0; i < pending.length; i++) {
          pending[i]();
        }
      });
    }
    module.exports = runtime;
  }
});
export default require_hot_reload();
//# sourceMappingURL=marko_src_runtime_vdom_hot-reload__js.js.map
