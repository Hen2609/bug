import {
  require_dom_data,
  require_index_browser
} from "./chunk-GSFJVMIM.js";
import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/raptor-util/copyProps.js
var require_copyProps = __commonJS({
  "node_modules/raptor-util/copyProps.js"(exports, module) {
    module.exports = function copyProps(from, to) {
      Object.getOwnPropertyNames(from).forEach(function(name) {
        var descriptor = Object.getOwnPropertyDescriptor(from, name);
        Object.defineProperty(to, name, descriptor);
      });
    };
  }
});

// node_modules/raptor-util/inherit.js
var require_inherit = __commonJS({
  "node_modules/raptor-util/inherit.js"(exports, module) {
    var copyProps = require_copyProps();
    function inherit(ctor, superCtor, shouldCopyProps) {
      var oldProto = ctor.prototype;
      var newProto = ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          writable: true,
          configurable: true
        }
      });
      if (oldProto && shouldCopyProps !== false) {
        copyProps(oldProto, newProto);
      }
      ctor.$super = superCtor;
      ctor.prototype = newProto;
      return ctor;
    }
    module.exports = inherit;
    inherit._inherit = inherit;
  }
});

// node_modules/marko/src/runtime/vdom/VNode.js
var require_VNode = __commonJS({
  "node_modules/marko/src/runtime/vdom/VNode.js"(exports, module) {
    function VNode() {
    }
    VNode.prototype = {
      ___VNode: function(finalChildCount, ownerComponent) {
        this.___finalChildCount = finalChildCount;
        this.___childCount = 0;
        this.___firstChildInternal = null;
        this.___lastChild = null;
        this.___parentNode = null;
        this.___nextSiblingInternal = null;
        this.___ownerComponent = ownerComponent;
      },
      get ___firstChild() {
        var firstChild = this.___firstChildInternal;
        if (firstChild && firstChild.___DocumentFragment) {
          var nestedFirstChild = firstChild.___firstChild;
          return nestedFirstChild || firstChild.___nextSibling;
        }
        return firstChild;
      },
      get ___nextSibling() {
        var nextSibling = this.___nextSiblingInternal;
        if (nextSibling) {
          if (nextSibling.___DocumentFragment) {
            var firstChild = nextSibling.___firstChild;
            return firstChild || nextSibling.___nextSibling;
          }
        } else {
          var parentNode = this.___parentNode;
          if (parentNode && parentNode.___DocumentFragment) {
            return parentNode.___nextSibling;
          }
        }
        return nextSibling;
      },
      ___appendChild: function(child) {
        this.___childCount++;
        if (this.___nodeName === "textarea") {
          if (child.___Text) {
            var childValue = child.___nodeValue;
            this.___valueInternal = (this.___valueInternal || "") + childValue;
          } else if (child.___preserve || child.___preserveBody) {
            this.___preserveTextAreaValue = true;
          } else {
            throw TypeError();
          }
        } else {
          var lastChild = this.___lastChild;
          child.___parentNode = this;
          if (lastChild) {
            lastChild.___nextSiblingInternal = child;
          } else {
            this.___firstChildInternal = child;
          }
          this.___lastChild = child;
        }
        return child;
      },
      ___finishChild: function finishChild() {
        if (this.___childCount === this.___finalChildCount && this.___parentNode) {
          return this.___parentNode.___finishChild();
        } else {
          return this;
        }
      }
    };
    module.exports = VNode;
  }
});

// node_modules/marko/src/runtime/vdom/VElement.js
var require_VElement = __commonJS({
  "node_modules/marko/src/runtime/vdom/VElement.js"(exports, module) {
    var domData = require_dom_data();
    var componentsUtil = require_index_browser();
    var vElementByDOMNode = domData.___vElementByDOMNode;
    var VNode = require_VNode();
    var inherit = require_inherit();
    var ATTR_XLINK_HREF = "xlink:href";
    var xmlnsRegExp = /^xmlns(:|$)/;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var NS_XLINK = "http://www.w3.org/1999/xlink";
    var NS_HTML = "http://www.w3.org/1999/xhtml";
    var NS_MATH = "http://www.w3.org/1998/Math/MathML";
    var NS_SVG = "http://www.w3.org/2000/svg";
    var DEFAULT_NS = {
      svg: NS_SVG,
      math: NS_MATH
    };
    var FLAG_SIMPLE_ATTRS = 1;
    var FLAG_CUSTOM_ELEMENT = 2;
    var FLAG_SPREAD_ATTRS = 4;
    var defineProperty = Object.defineProperty;
    var ATTR_HREF = "href";
    var EMPTY_OBJECT = Object.freeze({});
    function convertAttrValue(type, value) {
      if (value === true) {
        return "";
      } else if (type == "object") {
        if (value instanceof RegExp) {
          return value.source;
        }
      }
      return value + "";
    }
    function assign(a, b) {
      for (var key in b) {
        if (hasOwnProperty.call(b, key)) {
          a[key] = b[key];
        }
      }
    }
    function setAttribute(el, namespaceURI, name, value) {
      if (namespaceURI === null) {
        el.setAttribute(name, value);
      } else {
        el.setAttributeNS(namespaceURI, name, value);
      }
    }
    function removeAttribute(el, namespaceURI, name) {
      if (namespaceURI === null) {
        el.removeAttribute(name);
      } else {
        el.removeAttributeNS(namespaceURI, name);
      }
    }
    function VElementClone(other) {
      this.___firstChildInternal = other.___firstChildInternal;
      this.___parentNode = null;
      this.___nextSiblingInternal = null;
      this.___key = other.___key;
      this.___attributes = other.___attributes;
      this.___properties = other.___properties;
      this.___nodeName = other.___nodeName;
      this.___flags = other.___flags;
      this.___valueInternal = other.___valueInternal;
      this.___constId = other.___constId;
    }
    function VElement(tagName, attrs, key, ownerComponent, childCount, flags, props) {
      this.___VNode(childCount, ownerComponent);
      var constId;
      if (props) {
        constId = props.i;
      }
      this.___key = key;
      this.___flags = flags || 0;
      this.___attributes = attrs || EMPTY_OBJECT;
      this.___properties = props || EMPTY_OBJECT;
      this.___nodeName = tagName;
      this.___valueInternal = null;
      this.___constId = constId;
      this.___preserve = false;
      this.___preserveBody = false;
    }
    VElement.prototype = {
      ___nodeType: 1,
      ___cloneNode: function() {
        return new VElementClone(this);
      },
      e: function(tagName, attrs, key, ownerComponent, childCount, flags, props) {
        var child = this.___appendChild(
          new VElement(
            tagName,
            attrs,
            key,
            ownerComponent,
            childCount,
            flags,
            props
          )
        );
        if (childCount === 0) {
          return this.___finishChild();
        } else {
          return child;
        }
      },
      n: function(node, ownerComponent) {
        node = node.___cloneNode();
        node.___ownerComponent = ownerComponent;
        this.___appendChild(node);
        return this.___finishChild();
      },
      ___actualize: function(host, parentNamespaceURI) {
        var tagName = this.___nodeName;
        var attributes = this.___attributes;
        var namespaceURI = DEFAULT_NS[tagName] || parentNamespaceURI || NS_HTML;
        var flags = this.___flags;
        var el = (host.ownerDocument || host).createElementNS(
          namespaceURI,
          tagName
        );
        if (flags & FLAG_CUSTOM_ELEMENT) {
          assign(el, attributes);
        } else {
          for (var attrName in attributes) {
            var attrValue = attributes[attrName];
            if (attrValue !== false && attrValue != null) {
              var type = typeof attrValue;
              if (type !== "string") {
                attrValue = convertAttrValue(type, attrValue);
              }
              if (attrName == ATTR_XLINK_HREF) {
                setAttribute(el, NS_XLINK, ATTR_HREF, attrValue);
              } else {
                el.setAttribute(attrName, attrValue);
              }
            }
          }
          if (tagName === "textarea") {
            el.defaultValue = el.value = this.___value;
          }
        }
        vElementByDOMNode.set(el, this);
        return el;
      },
      ___hasAttribute: function(name) {
        var value = this.___attributes[name];
        return value != null && value !== false;
      }
    };
    inherit(VElement, VNode);
    var proto = VElementClone.prototype = VElement.prototype;
    ["checked", "selected", "disabled"].forEach(function(name) {
      defineProperty(proto, name, {
        get: function() {
          var value = this.___attributes[name];
          return value !== false && value != null;
        }
      });
    });
    defineProperty(proto, "___value", {
      get: function() {
        var value = this.___valueInternal;
        if (value == null) {
          value = this.___attributes.value;
        }
        return value != null && value !== false ? value + "" : this.___attributes.type === "checkbox" || this.___attributes.type === "radio" ? "on" : "";
      }
    });
    VElement.___removePreservedAttributes = function(attrs) {
      return attrs;
    };
    function virtualizeElement(node, virtualizeChildNodes, ownerComponent) {
      var attributes = node.attributes;
      var attrCount = attributes.length;
      var attrs = null;
      var props = null;
      if (attrCount) {
        attrs = {};
        for (var i = 0; i < attrCount; i++) {
          var attr = attributes[i];
          var attrName = attr.name;
          if (!xmlnsRegExp.test(attrName)) {
            if (attrName === "data-marko") {
              props = componentsUtil.___getMarkoPropsFromEl(node);
            } else if (attr.namespaceURI === NS_XLINK) {
              attrs[ATTR_XLINK_HREF] = attr.value;
            } else {
              attrs[attrName] = attr.value;
            }
          }
        }
      }
      var tagName = node.nodeName;
      if (node.namespaceURI === NS_HTML) {
        tagName = tagName.toLowerCase();
      }
      var vdomEl = new VElement(
        tagName,
        attrs,
        null,
        ownerComponent,
        0,
        0,
        props
      );
      if (vdomEl.___nodeName === "textarea") {
        vdomEl.___valueInternal = node.value;
      } else if (virtualizeChildNodes) {
        virtualizeChildNodes(node, vdomEl, ownerComponent);
      }
      return vdomEl;
    }
    VElement.___virtualize = virtualizeElement;
    VElement.___morphAttrs = function(fromEl, vFromEl, toEl) {
      var removePreservedAttributes = VElement.___removePreservedAttributes;
      var fromFlags = vFromEl.___flags;
      var toFlags = toEl.___flags;
      vElementByDOMNode.set(fromEl, toEl);
      var attrs = toEl.___attributes;
      var props = toEl.___properties;
      if (toFlags & FLAG_CUSTOM_ELEMENT) {
        return assign(fromEl, attrs);
      }
      var attrName;
      var oldAttrs = vFromEl.___attributes;
      if (oldAttrs) {
        if (oldAttrs === attrs) {
          return;
        } else {
          oldAttrs = removePreservedAttributes(oldAttrs, props);
        }
      }
      var attrValue;
      if (toFlags & FLAG_SIMPLE_ATTRS && fromFlags & FLAG_SIMPLE_ATTRS) {
        if (oldAttrs["class"] !== (attrValue = attrs["class"])) {
          fromEl.className = attrValue;
        }
        if (oldAttrs.id !== (attrValue = attrs.id)) {
          fromEl.id = attrValue;
        }
        if (oldAttrs.style !== (attrValue = attrs.style)) {
          fromEl.style.cssText = attrValue;
        }
        return;
      }
      attrs = removePreservedAttributes(attrs, props, true);
      var namespaceURI;
      for (attrName in attrs) {
        attrValue = attrs[attrName];
        namespaceURI = null;
        if (attrName === ATTR_XLINK_HREF) {
          namespaceURI = NS_XLINK;
          attrName = ATTR_HREF;
        }
        if (attrValue == null || attrValue === false) {
          removeAttribute(fromEl, namespaceURI, attrName);
        } else if (oldAttrs[attrName] !== attrValue) {
          var type = typeof attrValue;
          if (type !== "string") {
            attrValue = convertAttrValue(type, attrValue);
          }
          setAttribute(fromEl, namespaceURI, attrName, attrValue);
        }
      }
      if (toEl.___key === null || fromFlags & FLAG_SPREAD_ATTRS) {
        for (attrName in oldAttrs) {
          if (!(attrName in attrs)) {
            if (attrName === ATTR_XLINK_HREF) {
              fromEl.removeAttributeNS(ATTR_XLINK_HREF, ATTR_HREF);
            } else {
              fromEl.removeAttribute(attrName);
            }
          }
        }
      }
    };
    module.exports = VElement;
  }
});

export {
  require_copyProps,
  require_inherit,
  require_VNode,
  require_VElement
};
//# sourceMappingURL=chunk-DNVSKMP5.js.map
