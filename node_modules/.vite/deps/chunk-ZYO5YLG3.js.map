{
  "version": 3,
  "sources": ["../../marko/src/runtime/vdom/morphdom/specialElHandlers.js", "../../marko/src/runtime/vdom/morphdom/index.js"],
  "sourcesContent": ["function syncBooleanAttrProp(fromEl, toEl, name) {\n  if (fromEl[name] !== toEl[name]) {\n    fromEl[name] = toEl[name];\n    if (fromEl[name]) {\n      fromEl.setAttribute(name, \"\");\n    } else {\n      fromEl.removeAttribute(name, \"\");\n    }\n  }\n}\n\nfunction forEachOption(el, fn, i) {\n  var curChild = el.___firstChild;\n\n  while (curChild) {\n    if (curChild.___nodeName === \"option\") {\n      fn(curChild, ++i);\n    } else {\n      i = forEachOption(curChild, fn, i);\n    }\n\n    curChild = curChild.___nextSibling;\n  }\n\n  return i;\n}\n\n// We use a JavaScript class to benefit from fast property lookup\nfunction SpecialElHandlers() {}\nSpecialElHandlers.prototype = {\n  /**\n   * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n   * attribute when reading over the attributes using selectEl.attributes\n   */\n  option: function (fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"selected\");\n  },\n  button: function (fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n  },\n  /**\n   * The \"value\" attribute is special for the <input> element since it sets\n   * the initial value. Changing the \"value\" attribute without changing the\n   * \"value\" property will have no effect since it is only used to the set the\n   * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n   */\n  input: function (fromEl, toEl) {\n    syncBooleanAttrProp(fromEl, toEl, \"checked\");\n    syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n\n    if (fromEl.value != toEl.___value) {\n      fromEl.value = toEl.___value;\n    }\n\n    if (fromEl.hasAttribute(\"value\") && !toEl.___hasAttribute(\"value\")) {\n      fromEl.removeAttribute(\"value\");\n    }\n  },\n\n  textarea: function (fromEl, toEl) {\n    if (toEl.___preserveTextAreaValue) {\n      return;\n    }\n\n    var newValue = toEl.___value;\n    if (fromEl.value != newValue) {\n      fromEl.value = newValue;\n    }\n\n    var firstChild = fromEl.firstChild;\n    if (firstChild) {\n      // Needed for IE. Apparently IE sets the placeholder as the\n      // node value and vise versa. This ignores an empty update.\n      var oldValue = firstChild.nodeValue;\n\n      if (\n        oldValue == newValue ||\n        (!newValue && oldValue == fromEl.placeholder)\n      ) {\n        return;\n      }\n\n      firstChild.nodeValue = newValue;\n    }\n  },\n  select: function (fromEl, toEl) {\n    if (!toEl.___hasAttribute(\"multiple\")) {\n      var selected = 0;\n      forEachOption(\n        toEl,\n        function (option, i) {\n          if (option.___hasAttribute(\"selected\")) {\n            selected = i;\n          }\n        },\n        -1\n      );\n\n      if (fromEl.selectedIndex !== selected) {\n        fromEl.selectedIndex = selected;\n      }\n    }\n  }\n};\n\nmodule.exports = new SpecialElHandlers();\n", "\"use strict\";\nvar specialElHandlers = require(\"./specialElHandlers\");\nvar KeySequence = require(\"../../components/KeySequence\");\nvar componentsUtil = require(\"../../components/util\");\nvar existingComponentLookup = componentsUtil.___componentLookup;\nvar destroyNodeRecursive = componentsUtil.___destroyNodeRecursive;\nvar addComponentRootToKeyedElements =\n  componentsUtil.___addComponentRootToKeyedElements;\nvar normalizeComponentKey = componentsUtil.___normalizeComponentKey;\nvar VElement = require(\"../vdom\").___VElement;\nvar virtualizeElement = VElement.___virtualize;\nvar morphAttrs = VElement.___morphAttrs;\nvar eventDelegation = require(\"../../components/event-delegation\");\nvar fragment = require(\"./fragment\");\nvar helpers = require(\"./helpers\");\nvar domData = require(\"../../components/dom-data\");\nvar keysByDOMNode = domData.___keyByDOMNode;\nvar componentByDOMNode = domData.___componentByDOMNode;\nvar vElementByDOMNode = domData.___vElementByDOMNode;\nvar detachedByDOMNode = domData.___detachedByDOMNode;\n\nvar insertBefore = helpers.___insertBefore;\nvar insertAfter = helpers.___insertAfter;\nvar nextSibling = helpers.___nextSibling;\nvar firstChild = helpers.___firstChild;\nvar removeChild = helpers.___removeChild;\nvar createFragmentNode = fragment.___createFragmentNode;\nvar beginFragmentNode = fragment.___beginFragmentNode;\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar COMPONENT_NODE = 2;\nvar FRAGMENT_NODE = 12;\nvar DOCTYPE_NODE = 10;\n\n// var FLAG_SIMPLE_ATTRS = 1;\n// var FLAG_CUSTOM_ELEMENT = 2;\n// var FLAG_SPREAD_ATTRS = 4;\n\nfunction isAutoKey(key) {\n  return key[0] !== \"@\";\n}\n\nfunction compareNodeNames(fromEl, toEl) {\n  return fromEl.___nodeName === toEl.___nodeName;\n}\n\nfunction caseInsensitiveCompare(a, b) {\n  return a.toLowerCase() === b.toLowerCase();\n}\n\nfunction onNodeAdded(node, componentsContext) {\n  if (node.nodeType === ELEMENT_NODE) {\n    eventDelegation.___handleNodeAttach(node, componentsContext);\n  }\n}\n\nfunction morphdom(fromNode, toNode, host, componentsContext) {\n  var globalComponentsContext;\n  var isHydrate = false;\n  var keySequences = Object.create(null);\n\n  if (componentsContext) {\n    globalComponentsContext = componentsContext.___globalContext;\n    isHydrate = globalComponentsContext.___isHydrate;\n  }\n\n  function insertVirtualNodeBefore(\n    vNode,\n    key,\n    referenceEl,\n    parentEl,\n    ownerComponent,\n    parentComponent\n  ) {\n    var realNode = vNode.___actualize(host, parentEl.namespaceURI);\n    insertBefore(realNode, referenceEl, parentEl);\n\n    if (\n      vNode.___nodeType === ELEMENT_NODE ||\n      vNode.___nodeType === FRAGMENT_NODE\n    ) {\n      if (key) {\n        keysByDOMNode.set(realNode, key);\n        (isAutoKey(key) ? parentComponent : ownerComponent).___keyedElements[\n          key\n        ] = realNode;\n      }\n\n      if (vNode.___nodeName !== \"textarea\") {\n        morphChildren(realNode, vNode, parentComponent);\n      }\n\n      onNodeAdded(realNode, componentsContext);\n    }\n  }\n\n  function insertVirtualComponentBefore(\n    vComponent,\n    referenceNode,\n    referenceNodeParentEl,\n    component,\n    key,\n    ownerComponent,\n    parentComponent\n  ) {\n    var rootNode = (component.___rootNode = insertBefore(\n      createFragmentNode(),\n      referenceNode,\n      referenceNodeParentEl\n    ));\n    componentByDOMNode.set(rootNode, component);\n\n    if (key && ownerComponent) {\n      key = normalizeComponentKey(key, parentComponent.id);\n      addComponentRootToKeyedElements(\n        ownerComponent.___keyedElements,\n        key,\n        rootNode,\n        component.id\n      );\n      keysByDOMNode.set(rootNode, key);\n    }\n\n    morphComponent(component, vComponent);\n  }\n\n  function morphComponent(component, vComponent) {\n    morphChildren(component.___rootNode, vComponent, component);\n  }\n\n  var detachedNodes = [];\n\n  function detachNode(node, parentNode, ownerComponent) {\n    if (node.nodeType === ELEMENT_NODE || node.nodeType === FRAGMENT_NODE) {\n      detachedNodes.push(node);\n      detachedByDOMNode.set(node, ownerComponent || true);\n    } else {\n      destroyNodeRecursive(node);\n      removeChild(node);\n    }\n  }\n\n  function destroyComponent(component) {\n    component.destroy();\n  }\n\n  function morphChildren(fromNode, toNode, parentComponent) {\n    var curFromNodeChild = firstChild(fromNode);\n    var curToNodeChild = toNode.___firstChild;\n\n    var curToNodeKey;\n    var curFromNodeKey;\n    var curToNodeType;\n\n    var fromNextSibling;\n    var toNextSibling;\n    var matchingFromEl;\n    var matchingFromComponent;\n    var curVFromNodeChild;\n    var fromComponent;\n\n    outer: while (curToNodeChild) {\n      toNextSibling = curToNodeChild.___nextSibling;\n      curToNodeType = curToNodeChild.___nodeType;\n      curToNodeKey = curToNodeChild.___key;\n\n      // Skip <!doctype>\n      if (curFromNodeChild && curFromNodeChild.nodeType === DOCTYPE_NODE) {\n        curFromNodeChild = nextSibling(curFromNodeChild);\n      }\n\n      var ownerComponent = curToNodeChild.___ownerComponent || parentComponent;\n      var referenceComponent;\n\n      if (curToNodeType === COMPONENT_NODE) {\n        var component = curToNodeChild.___component;\n        if (\n          (matchingFromComponent = existingComponentLookup[component.id]) ===\n          undefined\n        ) {\n          if (isHydrate === true) {\n            var rootNode = beginFragmentNode(curFromNodeChild, fromNode);\n            component.___rootNode = rootNode;\n            componentByDOMNode.set(rootNode, component);\n\n            if (ownerComponent && curToNodeKey) {\n              curToNodeKey = normalizeComponentKey(\n                curToNodeKey,\n                parentComponent.id\n              );\n              addComponentRootToKeyedElements(\n                ownerComponent.___keyedElements,\n                curToNodeKey,\n                rootNode,\n                component.id\n              );\n\n              keysByDOMNode.set(rootNode, curToNodeKey);\n            }\n\n            morphComponent(component, curToNodeChild);\n\n            curFromNodeChild = nextSibling(rootNode);\n          } else {\n            insertVirtualComponentBefore(\n              curToNodeChild,\n              curFromNodeChild,\n              fromNode,\n              component,\n              curToNodeKey,\n              ownerComponent,\n              parentComponent\n            );\n          }\n        } else {\n          if (matchingFromComponent.___rootNode !== curFromNodeChild) {\n            if (\n              curFromNodeChild &&\n              (fromComponent = componentByDOMNode.get(curFromNodeChild)) &&\n              globalComponentsContext.___renderedComponentsById[\n                fromComponent.id\n              ] === undefined\n            ) {\n              // The component associated with the current real DOM node was not rendered\n              // so we should just remove it out of the real DOM by destroying it\n              curFromNodeChild = nextSibling(fromComponent.___rootNode);\n              destroyComponent(fromComponent);\n              continue;\n            }\n\n            // We need to move the existing component into\n            // the correct location\n            insertBefore(\n              matchingFromComponent.___rootNode,\n              curFromNodeChild,\n              fromNode\n            );\n          } else {\n            curFromNodeChild =\n              curFromNodeChild && nextSibling(curFromNodeChild);\n          }\n\n          if (!curToNodeChild.___preserve) {\n            morphComponent(component, curToNodeChild);\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        continue;\n      } else if (curToNodeKey) {\n        curVFromNodeChild = undefined;\n        curFromNodeKey = undefined;\n        var curToNodeKeyOriginal = curToNodeKey;\n\n        if (isAutoKey(curToNodeKey)) {\n          if (ownerComponent !== parentComponent) {\n            curToNodeKey += \":\" + ownerComponent.id;\n          }\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent = ownerComponent;\n        }\n\n        // We have a keyed element. This is the fast path for matching\n        // up elements\n        curToNodeKey = (\n          keySequences[referenceComponent.id] ||\n          (keySequences[referenceComponent.id] = new KeySequence())\n        ).___nextKey(curToNodeKey);\n\n        if (curFromNodeChild) {\n          curFromNodeKey = keysByDOMNode.get(curFromNodeChild);\n          curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n          fromNextSibling = nextSibling(curFromNodeChild);\n        }\n\n        if (curFromNodeKey === curToNodeKey) {\n          // Elements line up. Now we just have to make sure they are compatible\n          if (!curToNodeChild.___preserve) {\n            // We just skip over the fromNode if it is preserved\n\n            if (compareNodeNames(curToNodeChild, curVFromNodeChild)) {\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent\n              );\n            } else {\n              // Remove the old node\n              detachNode(curFromNodeChild, fromNode, ownerComponent);\n\n              // Incompatible nodes. Just move the target VNode into the DOM at this position\n              insertVirtualNodeBefore(\n                curToNodeChild,\n                curToNodeKey,\n                curFromNodeChild,\n                fromNode,\n                ownerComponent,\n                parentComponent\n              );\n            }\n          }\n        } else {\n          matchingFromEl = referenceComponent.___keyedElements[curToNodeKey];\n          if (\n            matchingFromEl === undefined ||\n            matchingFromEl === curFromNodeChild\n          ) {\n            if (isHydrate === true && curFromNodeChild) {\n              if (\n                curFromNodeChild.nodeType === ELEMENT_NODE &&\n                (curToNodeChild.___preserve ||\n                  caseInsensitiveCompare(\n                    curFromNodeChild.nodeName,\n                    curToNodeChild.___nodeName || \"\"\n                  ))\n              ) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n                curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                keysByDOMNode.set(curFromNodeChild, curToNodeKey);\n                referenceComponent.___keyedElements[curToNodeKey] =\n                  curFromNodeChild;\n\n                if (curToNodeChild.___preserve) {\n                  vElementByDOMNode.set(curFromNodeChild, curVFromNodeChild);\n                } else {\n                  morphEl(\n                    curFromNodeChild,\n                    curVFromNodeChild,\n                    curToNodeChild,\n                    parentComponent\n                  );\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n                continue;\n              } else if (\n                curToNodeChild.___nodeType === FRAGMENT_NODE &&\n                curFromNodeChild.nodeType === COMMENT_NODE\n              ) {\n                var content = curFromNodeChild.nodeValue;\n                if (content == \"F#\" + curToNodeKeyOriginal) {\n                  var endNode = curFromNodeChild.nextSibling;\n                  var depth = 0;\n                  var nodeValue;\n\n                  // eslint-disable-next-line no-constant-condition\n                  while (true) {\n                    if (endNode.nodeType === COMMENT_NODE) {\n                      nodeValue = endNode.nodeValue;\n                      if (nodeValue === \"F/\") {\n                        if (depth === 0) {\n                          break;\n                        } else {\n                          depth--;\n                        }\n                      } else if (nodeValue.indexOf(\"F#\") === 0) {\n                        depth++;\n                      }\n                    }\n                    endNode = endNode.nextSibling;\n                  }\n\n                  var fragment = createFragmentNode(\n                    curFromNodeChild,\n                    endNode.nextSibling,\n                    fromNode\n                  );\n                  keysByDOMNode.set(fragment, curToNodeKey);\n                  vElementByDOMNode.set(fragment, curToNodeChild);\n                  referenceComponent.___keyedElements[curToNodeKey] = fragment;\n                  removeChild(curFromNodeChild);\n                  removeChild(endNode);\n\n                  if (!curToNodeChild.___preserve) {\n                    morphChildren(fragment, curToNodeChild, parentComponent);\n                  }\n\n                  curToNodeChild = toNextSibling;\n                  curFromNodeChild = fragment.nextSibling;\n                  continue;\n                }\n              }\n            }\n\n            insertVirtualNodeBefore(\n              curToNodeChild,\n              curToNodeKey,\n              curFromNodeChild,\n              fromNode,\n              ownerComponent,\n              parentComponent\n            );\n            fromNextSibling = curFromNodeChild;\n          } else {\n            if (detachedByDOMNode.get(matchingFromEl) !== undefined) {\n              detachedByDOMNode.set(matchingFromEl, undefined);\n            }\n\n            if (!curToNodeChild.___preserve) {\n              curVFromNodeChild = vElementByDOMNode.get(matchingFromEl);\n\n              if (compareNodeNames(curVFromNodeChild, curToNodeChild)) {\n                if (fromNextSibling === matchingFromEl) {\n                  // Single element removal:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     D\n                  // D\n                  //\n                  // Single element swap:\n                  // A <-> A\n                  // B <-> C <-- We are here\n                  // C     B\n\n                  if (\n                    toNextSibling &&\n                    toNextSibling.___key === curFromNodeKey\n                  ) {\n                    // Single element swap\n\n                    // We want to stay on the current real DOM node\n                    fromNextSibling = curFromNodeChild;\n\n                    // But move the matching element into place\n                    insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n                  } else {\n                    // Single element removal\n\n                    // We need to remove the current real DOM node\n                    // and the matching real DOM node will fall into\n                    // place. We will continue diffing with next sibling\n                    // after the real DOM node that just fell into place\n                    fromNextSibling = nextSibling(fromNextSibling);\n\n                    if (curFromNodeChild) {\n                      detachNode(curFromNodeChild, fromNode, ownerComponent);\n                    }\n                  }\n                } else {\n                  // A <-> A\n                  // B <-> D <-- We are here\n                  // C\n                  // D\n\n                  // We need to move the matching node into place\n                  insertAfter(matchingFromEl, curFromNodeChild, fromNode);\n\n                  if (curFromNodeChild) {\n                    detachNode(curFromNodeChild, fromNode, ownerComponent);\n                  }\n                }\n\n                morphEl(\n                  matchingFromEl,\n                  curVFromNodeChild,\n                  curToNodeChild,\n                  parentComponent\n                );\n              } else {\n                insertVirtualNodeBefore(\n                  curToNodeChild,\n                  curToNodeKey,\n                  curFromNodeChild,\n                  fromNode,\n                  ownerComponent,\n                  parentComponent\n                );\n                detachNode(matchingFromEl, fromNode, ownerComponent);\n              }\n            } else {\n              // preserve the node\n              // but still we need to diff the current from node\n              insertBefore(matchingFromEl, curFromNodeChild, fromNode);\n              fromNextSibling = curFromNodeChild;\n            }\n          }\n        }\n\n        curToNodeChild = toNextSibling;\n        curFromNodeChild = fromNextSibling;\n        continue;\n      }\n\n      // The know the target node is not a VComponent node and we know\n      // it is also not a preserve node. Let's now match up the HTML\n      // element, text node, comment, etc.\n      while (curFromNodeChild) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          // The current \"to\" element is not associated with a component,\n          // but the current \"from\" element is associated with a component\n\n          // Even if we destroy the current component in the original\n          // DOM or not, we still need to skip over it since it is\n          // not compatible with the current \"to\" node\n          curFromNodeChild = fromNextSibling;\n\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n\n          continue; // Move to the next \"from\" node\n        }\n\n        var curFromNodeType = curFromNodeChild.nodeType;\n\n        var isCompatible = undefined;\n\n        if (curFromNodeType === curToNodeType) {\n          if (curFromNodeType === ELEMENT_NODE) {\n            // Both nodes being compared are Element nodes\n            curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n            if (curVFromNodeChild === undefined) {\n              if (isHydrate === true) {\n                curVFromNodeChild = virtualizeElement(curFromNodeChild);\n\n                if (\n                  caseInsensitiveCompare(\n                    curVFromNodeChild.___nodeName,\n                    curToNodeChild.___nodeName\n                  )\n                ) {\n                  curVFromNodeChild.___nodeName = curToNodeChild.___nodeName;\n                }\n              } else {\n                // Skip over nodes that don't look like ours...\n                curFromNodeChild = fromNextSibling;\n                continue;\n              }\n            } else if ((curFromNodeKey = curVFromNodeChild.___key)) {\n              // We have a keyed element here but our target VDOM node\n              // is not keyed so this not doesn't belong\n              isCompatible = false;\n            }\n\n            isCompatible =\n              isCompatible !== false &&\n              compareNodeNames(curVFromNodeChild, curToNodeChild) === true;\n\n            if (isCompatible === true) {\n              // We found compatible DOM elements so transform\n              // the current \"from\" node to match the current\n              // target DOM node.\n              morphEl(\n                curFromNodeChild,\n                curVFromNodeChild,\n                curToNodeChild,\n                parentComponent\n              );\n            }\n          } else if (\n            curFromNodeType === TEXT_NODE ||\n            curFromNodeType === COMMENT_NODE\n          ) {\n            // Both nodes being compared are Text or Comment nodes\n            isCompatible = true;\n            // Simply update nodeValue on the original node to\n            // change the text value\n\n            if (\n              isHydrate === true &&\n              toNextSibling &&\n              curFromNodeType === TEXT_NODE &&\n              toNextSibling.___nodeType === TEXT_NODE\n            ) {\n              fromNextSibling = curFromNodeChild.splitText(\n                curToNodeChild.___nodeValue.length\n              );\n            }\n            if (curFromNodeChild.nodeValue !== curToNodeChild.___nodeValue) {\n              curFromNodeChild.nodeValue = curToNodeChild.___nodeValue;\n            }\n          }\n        }\n\n        if (isCompatible === true) {\n          // Advance both the \"to\" child and the \"from\" child since we found a match\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n          continue outer;\n        }\n\n        detachNode(curFromNodeChild, fromNode, ownerComponent);\n        curFromNodeChild = fromNextSibling;\n      } // END: while (curFromNodeChild)\n\n      // If we got this far then we did not find a candidate match for\n      // our \"to node\" and we exhausted all of the children \"from\"\n      // nodes. Therefore, we will just append the current \"to\" node\n      // to the end\n      insertVirtualNodeBefore(\n        curToNodeChild,\n        curToNodeKey,\n        curFromNodeChild,\n        fromNode,\n        ownerComponent,\n        parentComponent\n      );\n\n      curToNodeChild = toNextSibling;\n      curFromNodeChild = fromNextSibling;\n    }\n\n    // We have processed all of the \"to nodes\".\n    if (fromNode.___finishFragment) {\n      // If we are in an unfinished fragment, we have reached the end of the nodes\n      // we were matching up and need to end the fragment\n      fromNode.___finishFragment(curFromNodeChild);\n    } else {\n      // If curFromNodeChild is non-null then we still have some from nodes\n      // left over that need to be removed\n      var fragmentBoundary =\n        fromNode.nodeType === FRAGMENT_NODE ? fromNode.endNode : null;\n\n      while (curFromNodeChild && curFromNodeChild !== fragmentBoundary) {\n        fromNextSibling = nextSibling(curFromNodeChild);\n\n        if ((fromComponent = componentByDOMNode.get(curFromNodeChild))) {\n          curFromNodeChild = fromNextSibling;\n          if (\n            !globalComponentsContext.___renderedComponentsById[fromComponent.id]\n          ) {\n            destroyComponent(fromComponent);\n          }\n          continue;\n        }\n\n        curVFromNodeChild = vElementByDOMNode.get(curFromNodeChild);\n        curFromNodeKey = keysByDOMNode.get(fromNode);\n\n        // For transcluded content, we need to check if the element belongs to a different component\n        // context than the current component and ensure it gets removed from its key index.\n        if (!curFromNodeKey || isAutoKey(curFromNodeKey)) {\n          referenceComponent = parentComponent;\n        } else {\n          referenceComponent =\n            curVFromNodeChild && curVFromNodeChild.___ownerComponent;\n        }\n\n        detachNode(curFromNodeChild, fromNode, referenceComponent);\n\n        curFromNodeChild = fromNextSibling;\n      }\n    }\n  }\n\n  function morphEl(fromEl, vFromEl, toEl, parentComponent) {\n    var nodeName = toEl.___nodeName;\n\n    var constId = toEl.___constId;\n    if (constId !== undefined && vFromEl.___constId === constId) {\n      return;\n    }\n\n    morphAttrs(fromEl, vFromEl, toEl);\n\n    if (toEl.___preserveBody) {\n      return;\n    }\n\n    if (nodeName !== \"textarea\") {\n      morphChildren(fromEl, toEl, parentComponent);\n    }\n\n    var specialElHandler = specialElHandlers[nodeName];\n    if (specialElHandler !== undefined) {\n      specialElHandler(fromEl, toEl);\n    }\n  } // END: morphEl(...)\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    componentsUtil.___stopDOMManipulationWarning(host);\n  }\n\n  morphChildren(fromNode, toNode, toNode.___component);\n\n  detachedNodes.forEach(function (node) {\n    var detachedFromComponent = detachedByDOMNode.get(node);\n\n    if (detachedFromComponent !== undefined) {\n      detachedByDOMNode.set(node, undefined);\n\n      var componentToDestroy = componentByDOMNode.get(node);\n      if (componentToDestroy) {\n        componentToDestroy.destroy();\n      } else if (node.parentNode) {\n        destroyNodeRecursive(\n          node,\n          detachedFromComponent !== true && detachedFromComponent\n        );\n\n        if (eventDelegation.___handleNodeDetach(node) != false) {\n          removeChild(node);\n        }\n      }\n    }\n  });\n\n  // eslint-disable-next-line no-constant-condition\n  if (\"MARKO_DEBUG\") {\n    componentsUtil.___startDOMManipulationWarning(host);\n  }\n}\n\nmodule.exports = morphdom;\n"],
  "mappings": "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",
  "names": ["fromNode", "toNode", "fragment"]
}
