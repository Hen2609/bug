import {
  require_queueMicrotask
} from "./chunk-XSOBGFXV.js";
import {
  require_complain
} from "./chunk-BXPA54VP.js";
import {
  __commonJS
} from "./chunk-TWLJ45QX.js";

// node_modules/marko/src/core-tags/core/await/AsyncValue.js
var require_AsyncValue = __commonJS({
  "node_modules/marko/src/core-tags/core/await/AsyncValue.js"(exports, module) {
    var queueMicrotask = require_queueMicrotask();
    function AsyncValue() {
      this.___value = void 0;
      this.___error = void 0;
      this.___callbacks = void 0;
      this.___settled = false;
    }
    function notifyCallbacks(asyncValue, err, value) {
      var callbacks = asyncValue.___callbacks;
      if (callbacks) {
        asyncValue.___callbacks = void 0;
        for (var i = 0; i < callbacks.length; i++) {
          var callback = callbacks[i];
          callback(err, value);
        }
      }
    }
    AsyncValue.prototype = {
      ___done: function(callback) {
        if (this.___settled) {
          return callback(this.___error, this.___value);
        }
        var callbacks = this.___callbacks || (this.___callbacks = []);
        callbacks.push(callback);
      },
      ___reject: function(err) {
        if (this.___settled) {
          return;
        }
        this.___error = err;
        this.___settled = true;
        notifyCallbacks(this, err, null);
      },
      ___resolve: function(value) {
        if (this.___settled) {
          return;
        }
        if (value && typeof value.then === "function") {
          var asyncValue = this;
          var finalPromise = value.then(
            function onFulfilled(value2) {
              queueMicrotask(asyncValue.___resolve.bind(asyncValue, value2));
            },
            function onRejected(err) {
              queueMicrotask(asyncValue.___reject.bind(asyncValue, err));
            }
          );
          if (finalPromise.done) {
            finalPromise.done();
          }
        } else {
          this.___value = value;
          this.___settled = true;
          notifyCallbacks(this, null, value);
        }
      }
    };
    module.exports = AsyncValue;
  }
});

// node_modules/marko/src/core-tags/core/await/renderer.js
var require_renderer = __commonJS({
  "node_modules/marko/src/core-tags/core/await/renderer.js"(exports, module) {
    var complain = require_complain();
    var AsyncValue = require_AsyncValue();
    function safeRenderBody(renderBody, targetOut, data) {
      try {
        renderBody(targetOut, data);
      } catch (err) {
        return err;
      }
    }
    function requestData(provider, timeout) {
      var asyncValue = new AsyncValue();
      if (typeof provider === "function") {
        if ("MARKO_DEBUG") {
          complain(
            "Passing a callback function to the <await> tag has been deprecated, please use a promise instead.",
            { level: 1, locationIndex: 3 }
          );
        }
        var callback = function(err, data) {
          if (err) {
            asyncValue.___reject(err);
          } else {
            asyncValue.___resolve(data);
          }
        };
        var value = provider.length === 1 ? provider(callback) : provider(null, callback);
        if (value !== void 0) {
          asyncValue.___resolve(value);
        }
      } else {
        asyncValue.___resolve(provider);
      }
      if (timeout == null) {
        timeout = 1e4;
      }
      var error;
      var errorMsg = "Timed out after " + timeout + "ms";
      if ("MARKO_DEBUG") {
        error = new Error(errorMsg);
      }
      if (timeout > 0) {
        let timeoutId = setTimeout(function() {
          timeoutId = null;
          if (!error)
            error = new Error(errorMsg);
          error.code = "ERR_AWAIT_TIMEDOUT";
          error.name = "TimeoutError";
          asyncValue.___reject(error);
        }, timeout);
        asyncValue.___done(function() {
          if (timeoutId != null) {
            clearTimeout(timeoutId);
          }
        });
      }
      return asyncValue;
    }
    var LAST_OPTIONS = { last: true, name: "await:finish" };
    module.exports = function awaitTag(input, out) {
      var clientReorder = typeof window === "undefined" && input.clientReorder === true && !out.isVDOM;
      var name = input.name || input._name;
      var timeout = input.timeout;
      var provider = input._provider;
      var asyncValue = requestData(provider, timeout);
      var placeholderRenderer = input.placeholder && input.placeholder.renderBody;
      if (asyncValue.___settled) {
        renderContents(asyncValue.___error, asyncValue.___value, input, out);
        return;
      }
      var asyncOut;
      var clientReorderContext;
      var awaitInfo = {
        name,
        clientReorder,
        dataProvider: provider
      };
      if (clientReorder) {
        awaitInfo.after = input.showAfter;
        clientReorderContext = out.global.___clientReorderContext || (out.global.___clientReorderContext = {
          instances: [],
          nextId: 0
        });
        var id = awaitInfo.id = input.name || clientReorderContext.nextId++;
        var placeholderIdAttrValue = "afph" + id;
        if (placeholderRenderer) {
          out.write('<span id="' + placeholderIdAttrValue + '">');
          placeholderRenderer(out);
          out.write("</span>");
        } else {
          out.write('<noscript id="' + placeholderIdAttrValue + '"></noscript>');
        }
        asyncOut = awaitInfo.out = out.createOut();
        var oldEmit = asyncOut.emit;
        asyncOut.emit = function(event) {
          if (event !== "finish" && event !== "error") {
            out.emit.apply(out, arguments);
          }
          oldEmit.apply(asyncOut, arguments);
        };
        if (clientReorderContext.instances) {
          clientReorderContext.instances.push(awaitInfo);
        }
        out.emit("await:clientReorder", awaitInfo);
      } else {
        out.flush();
        asyncOut = awaitInfo.out = out.beginAsync({
          timeout: 0,
          name
        });
      }
      var beforeRenderEmitted = false;
      out.emit("await:begin", awaitInfo);
      function renderBody(err, data) {
        if (awaitInfo.finished) {
          return;
        }
        if (err) {
          awaitInfo.error = err;
        }
        if (!beforeRenderEmitted) {
          beforeRenderEmitted = true;
          out.emit("await:beforeRender", awaitInfo);
        }
        renderContents(err, data, input, asyncOut);
        awaitInfo.finished = true;
        if (clientReorder) {
          asyncOut.end();
          out.flush();
        } else {
          let asyncLastOut = asyncOut.beginAsync(LAST_OPTIONS);
          asyncOut.onLast(function() {
            var oldWriter = asyncOut.writer;
            asyncOut.writer = asyncLastOut.writer;
            out.emit("await:finish", awaitInfo);
            asyncOut.writer = oldWriter;
            asyncLastOut.end();
            out.flush();
          });
          asyncOut.end();
        }
      }
      asyncValue.___done(renderBody);
    };
    function renderContents(err, data, input, out) {
      var resultRenderer = input.then && input.then.renderBody;
      var errorRenderer = input.catch && input.catch.renderBody;
      if (err) {
        if (input.catch) {
          if (errorRenderer) {
            errorRenderer(out, err);
          }
        } else {
          out.error(err);
        }
      } else {
        if (resultRenderer) {
          var renderBodyErr = safeRenderBody(resultRenderer, out, data);
          if (renderBodyErr) {
            return renderContents(renderBodyErr, data, input, out);
          }
        }
      }
    }
  }
});
export default require_renderer();
//# sourceMappingURL=marko_src_core-tags_core_await_renderer__js.js.map
