import {
  init_is_core_tag,
  isCoreTag
} from "./chunk-MU57322L.mjs";
import {
  importRuntimeDefault,
  init_import_runtime
} from "./chunk-BCNAFPHP.mjs";
import {
  closest,
  init_wrapper_component
} from "./chunk-TFXOVXSS.mjs";
import {
  __esm
} from "./chunk-XYON6ZHC.mjs";

// src/transform/hoist-tag-vars/transform.ts
import { types as t } from "@marko/compiler";
import { isNativeTag } from "@marko/babel-utils";
function getScopeRelation(scope, tag, ref) {
  const matchingScope = (parent) => parent.scope === scope && (parent.isMarkoScriptlet() || parent.isMarkoPlaceholder() || parent.isMarkoTag());
  const refParent = ref.findParent(matchingScope);
  const tagParent = tag.findParent(matchingScope);
  if (refParent.key === tagParent.key) {
    return 0 /* Same */;
  }
  return refParent.key < tagParent.key ? 1 /* Before */ : 2 /* After */;
}
function getReferenceType(ref) {
  let scope = ref.scope;
  while (scope.path.key === "callee" && scope.path.parentPath.isCallExpression()) {
    scope = scope.parent;
  }
  if (t.isProgram(scope.block) || t.isMarkoTagBody(scope.block)) {
    return 0 /* Sync */;
  }
  const closest2 = ref.findParent((parent) => parent.isMarkoAttribute());
  if (closest2) {
    const closestTag = closest2.parentPath;
    if (isNativeTag(closestTag) || isCoreTag("effect", closestTag) || isCoreTag("lifecycle", closestTag)) {
      return 1 /* Async */;
    }
  }
  return 2 /* Unknown */;
}
var transform_default;
var init_transform = __esm({
  "src/transform/hoist-tag-vars/transform.ts"() {
    init_is_core_tag();
    init_import_runtime();
    init_wrapper_component();
    transform_default = {
      MarkoTag: {
        exit(tag) {
          if (!tag.node.var) {
            return;
          }
          const {
            scope,
            hub: { file }
          } = tag;
          const tagVar = tag.get("var");
          const initializers = [];
          const meta = closest(tag.parentPath);
          for (const name in tagVar.getBindingIdentifiers()) {
            const binding = scope.getBinding(name);
            if (binding && binding.scope !== scope) {
              const hoistedId = binding.scope.generateUidIdentifier(`${binding.identifier.name}_hoisted`);
              let maybeHasSyncRefsBefore = false;
              const [assignment] = binding.constantViolations;
              if (assignment) {
                throw assignment.buildCodeFrameError(`Assigning to a hoisted tag variable is not supported in the tags api preview.`);
              }
              for (const ref of binding.referencePaths) {
                if (getScopeRelation(binding.scope, tag, ref) === 1 /* Before */) {
                  switch (getReferenceType(ref)) {
                    case 1 /* Async */:
                      break;
                    case 0 /* Sync */:
                      throw ref.buildCodeFrameError(`Cannot access '${name}' before initialization.`);
                    case 2 /* Unknown */:
                      maybeHasSyncRefsBefore = true;
                      ref.replaceWith(t.assignmentExpression("=", ref.node, t.callExpression(hoistedId, [])));
                      break;
                  }
                }
              }
              const hoistedDeclarators = [
                t.variableDeclarator(binding.identifier)
              ];
              if (maybeHasSyncRefsBefore) {
                hoistedDeclarators.push(t.variableDeclarator(hoistedId, t.callExpression(importRuntimeDefault(file, "transform/hoist-tag-vars", "hoist"), [
                  closest(binding.scope.path).component,
                  t.stringLiteral(name),
                  t.arrowFunctionExpression([t.identifier("_")], t.assignmentExpression("=", binding.identifier, t.identifier("_")))
                ])));
                initializers.push(t.expressionStatement(t.callExpression(hoistedId, [
                  meta.component,
                  binding.identifier
                ])));
              } else {
                hoistedDeclarators.push(t.variableDeclarator(hoistedId, t.arrowFunctionExpression([t.identifier("_")], t.assignmentExpression("=", binding.identifier, t.identifier("_")))));
                initializers.push(t.expressionStatement(t.callExpression(hoistedId, [binding.identifier])));
              }
              binding.scope.path.unshiftContainer("body", t.markoScriptlet([t.variableDeclaration("var", hoistedDeclarators)]));
            }
          }
          if (initializers.length) {
            tag.parentPath.pushContainer("body", t.markoScriptlet(initializers));
          }
        }
      }
    };
  }
});

export {
  transform_default,
  init_transform
};
