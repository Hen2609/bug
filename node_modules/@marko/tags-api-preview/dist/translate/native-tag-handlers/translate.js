var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var translate_exports = {};
__export(translate_exports, {
  default: () => translate_default
});
module.exports = __toCommonJS(translate_exports);
var import_compiler = require("@marko/compiler");
var import_babel_utils = require("@marko/babel-utils");
var import_import_runtime = require("../../util/import-runtime");
var import_is_api = __toESM(require("../../util/is-api"));
var import_get_attr = __toESM(require("../../util/get-attr"));
const eventNameReg = /^on[A-Z]/;
const changeNameReg = /Change$/;
const bindsByTag = {
  input: ["value", "checked"],
  textarea: ["value"]
};
var translate_default = {
  MarkoTag(tag) {
    if ((0, import_is_api.default)(tag, "tags") && (0, import_babel_utils.isNativeTag)(tag)) {
      const file = tag.hub.file;
      const isHTML = file.markoOpts.output === "html";
      const extra = tag.node.extra || (tag.node.extra = {});
      const meta = extra.properties || (extra.properties = []);
      const attrs = tag.get("attributes");
      if (attrs.some((it) => it.isMarkoSpreadAttribute())) {
        const metaId = tag.scope.generateUidIdentifier("meta");
        const properties = [];
        tag.insertBefore(import_compiler.types.variableDeclaration("var", [
          import_compiler.types.variableDeclarator(metaId, import_compiler.types.objectExpression([]))
        ]));
        meta.push(import_compiler.types.spreadElement(metaId));
        for (const attr of attrs) {
          if (attr.isMarkoAttribute()) {
            if (attr.node.name === "key")
              continue;
            properties.push(import_compiler.types.objectProperty(import_compiler.types.stringLiteral(attr.node.name), attr.node.value));
          } else {
            properties.push(import_compiler.types.spreadElement(attr.node.value));
          }
          attr.remove();
        }
        tag.pushContainer("attributes", import_compiler.types.markoSpreadAttribute(import_compiler.types.callExpression((0, import_import_runtime.importRuntimeDefault)(file, "translate/native-tag-handlers", "extractHandlers"), isHTML ? [import_compiler.types.objectExpression(properties)] : [
          import_compiler.types.objectExpression(properties),
          file._componentDefIdentifier,
          tag.node.name,
          metaId
        ])));
      } else {
        const tagName = tag.node.name.value;
        const binds = bindsByTag[tagName];
        for (const attr of attrs) {
          const { node } = attr;
          const { name, value } = node;
          if (isHTML) {
            if (eventNameReg.test(name) || changeNameReg.test(name)) {
              attr.remove();
            }
          } else if (eventNameReg.test(name) && value) {
            node.arguments = [value];
            node.value = import_compiler.types.booleanLiteral(true);
          }
        }
        if (binds) {
          const preserve = [];
          for (const name of binds) {
            const changeName = `${name}Change`;
            const valueAttr = (0, import_get_attr.default)(tag, name);
            const changeAttr = (0, import_get_attr.default)(tag, changeName);
            const nameLiteral = import_compiler.types.stringLiteral(name);
            if (changeAttr) {
              const eId = import_compiler.types.identifier("e");
              const targetId = import_compiler.types.identifier("target");
              const changeId = tag.scope.generateUidIdentifier(changeName);
              const changeValue = changeAttr.node.value;
              tag.insertBefore(import_compiler.types.variableDeclaration("var", [
                import_compiler.types.variableDeclarator(changeId, changeValue)
              ]));
              tag.pushContainer("attributes", import_compiler.types.markoAttribute("onInput", import_compiler.types.booleanLiteral(true), null, [
                import_compiler.types.arrowFunctionExpression([eId], import_compiler.types.blockStatement([
                  import_compiler.types.expressionStatement(import_compiler.types.callExpression(changeId, [
                    import_compiler.types.memberExpression(import_compiler.types.memberExpression(eId, targetId), import_compiler.types.identifier(name))
                  ]))
                ]))
              ]));
              changeAttr.remove();
              if (!isHTML && valueAttr && !import_compiler.types.isFunction(changeValue)) {
                preserve.push(import_compiler.types.logicalExpression("&&", changeId, nameLiteral));
              }
            } else if (!isHTML && valueAttr) {
              preserve.push(nameLiteral);
            }
          }
          if (preserve.length) {
            meta.push(import_compiler.types.objectProperty(import_compiler.types.identifier("pa"), import_compiler.types.arrayExpression(preserve)));
          }
        }
      }
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
