import {
  init_transform,
  replaceAssignments
} from "./chunk-UOJOZA4O.mjs";
import {
  __esm
} from "./chunk-XYON6ZHC.mjs";

// src/transform/assignments-to-change-call.ts
import { types as t } from "@marko/compiler";
function updateAssignmentsForIdentifier(identifier) {
  const binding = identifier.scope.getBinding(identifier.node.name);
  const assignments = binding.constantViolations;
  if (!assignments.length)
    return;
  let changeKey;
  let parent = identifier.parentPath;
  if (parent.isRestElement()) {
    throw assignments[0].buildCodeFrameError("Cannot assign to a ...rest element.");
  }
  if (parent.isAssignmentPattern()) {
    parent = parent.parentPath;
  }
  if (parent.isArrayPattern()) {
    throw assignments[0].buildCodeFrameError("Assignment to a destructured array will come in a future version of the tags api preview.");
  }
  if (parent.isObjectProperty()) {
    const pattern = parent.parentPath;
    if (parent.node.computed) {
      changeKey = identifier.scope.generateUidIdentifier(`${identifier.node.name}Change`);
      pattern.pushContainer("properties", t.objectProperty(t.binaryExpression("+", parent.get("key").node, t.stringLiteral("Change")), changeKey, true));
    } else {
      const key = parent.get("key");
      const searchKey = `${getStringOrIdentifierValue(key)}Change`;
      for (const prop of pattern.get("properties")) {
        if (prop.isObjectProperty()) {
          const propKey = prop.get("key");
          const propValue = prop.get("value");
          if (!prop.node.computed && getStringOrIdentifierValue(propKey) === searchKey && propValue.isIdentifier()) {
            changeKey = propValue.node;
            break;
          }
        }
      }
      if (!changeKey) {
        pattern.unshiftContainer("properties", t.objectProperty(t.stringLiteral(searchKey), changeKey = identifier.scope.generateUidIdentifier(searchKey)));
      }
    }
  }
  replaceAssignments(binding, changeKey);
}
function forEachBindingIdentifier(path, fn) {
  switch (path.node.type) {
    case "ObjectPattern":
      for (const prop of path.get("properties")) {
        forEachBindingIdentifier(prop.isObjectProperty() ? prop.get("value") : prop, fn);
      }
      break;
    case "ArrayPattern":
      for (const el of path.get("elements")) {
        forEachBindingIdentifier(el, fn);
      }
      break;
    case "RestElement":
      forEachBindingIdentifier(path.get("argument"), fn);
      break;
    case "AssignmentPattern":
      forEachBindingIdentifier(path.get("left"), fn);
      break;
    case "Identifier":
      fn(path);
      break;
  }
}
function getStringOrIdentifierValue(path) {
  return path.isStringLiteral() ? path.node.value : path.node.name;
}
var assignments_to_change_call_default;
var init_assignments_to_change_call = __esm({
  "src/transform/assignments-to-change-call.ts"() {
    init_transform();
    assignments_to_change_call_default = {
      MarkoTag: {
        exit(tag) {
          const tagVar = tag.get("var");
          if (!tagVar.node || tagVar.isIdentifier()) {
            return;
          }
          forEachBindingIdentifier(tagVar, updateAssignmentsForIdentifier);
        }
      }
    };
  }
});

export {
  assignments_to_change_call_default,
  init_assignments_to_change_call
};
