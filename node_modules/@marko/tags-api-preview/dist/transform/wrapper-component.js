var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var wrapper_component_exports = {};
__export(wrapper_component_exports, {
  closest: () => closest,
  default: () => wrapper_component_default,
  ensureLifecycle: () => ensureLifecycle
});
module.exports = __toCommonJS(wrapper_component_exports);
var import_compiler = require("@marko/compiler");
var import_babel_utils = require("@marko/babel-utils");
var import_taglib_id = require("../util/taglib-id");
var import_is_api = __toESM(require("../util/is-api"));
const lifecycleRootsForProgram = /* @__PURE__ */ new WeakMap();
const tagsNeedingLifecycle = /* @__PURE__ */ new Set([
  "id",
  "let",
  "get",
  "set",
  "effect",
  "return",
  "lifecycle"
]);
function closest(path) {
  let root = path;
  do {
    const { node } = root;
    if (!node) {
      return;
    }
    const { extra } = node;
    if (extra) {
      const meta = extra.___lifecycle;
      if (meta) {
        return meta;
      }
    }
    root = root.parentPath;
  } while (root);
}
var wrapper_component_default = {
  Program: {
    enter(program) {
      if ((0, import_is_api.default)(program, "tags")) {
        lifecycleRootsForProgram.set(program, /* @__PURE__ */ new Set());
      }
    },
    exit(program) {
      if ((0, import_is_api.default)(program, "tags")) {
        for (const root of lifecycleRootsForProgram.get(program)) {
          if (root === program) {
            if (root.node.extra.___lifecycle.client) {
              program.node.body = buildRootLifecycle(program).concat(program.node.body);
            }
          } else {
            root.node.body.body = buildNestedLifecycle(root);
          }
        }
      }
    }
  },
  MarkoTag(tag) {
    const tagDef = (0, import_babel_utils.getTagDef)(tag);
    if (tagDef && tagDef.taglibId === import_taglib_id.taglibId) {
      if (tagsNeedingLifecycle.has(tagDef.name)) {
        ensureLifecycle(tag, !(tagDef.name === "id" && tag.parent.type === "Program"));
      }
    } else if (tag.node.var) {
      ensureLifecycle(tag);
    }
  }
};
function ensureLifecycle(tag, client = true) {
  const program = tag.hub.file.path;
  let root = tag;
  while ((root = root.parentPath) !== program && (root = root.parentPath).node && (0, import_babel_utils.isNativeTag)(root))
    ;
  if (root.node) {
    const roots = lifecycleRootsForProgram.get(program);
    let extra = root.node.extra;
    if (roots.has(root)) {
      if (client)
        extra.___lifecycle.client = true;
    } else {
      const meta = {
        client,
        component: root.scope.generateUidIdentifier("component"),
        state: root.scope.generateUidIdentifier("state"),
        stateIndex: 0,
        refIndex: 0,
        varIndex: 0
      };
      roots.add(root);
      if (extra) {
        extra.___lifecycle = meta;
      } else {
        extra = root.node.extra = { ___lifecycle: meta };
      }
    }
    return extra.___lifecycle;
  }
}
function buildRootLifecycle(program) {
  const meta = program.node.extra.___lifecycle;
  return [
    import_compiler.types.markoClass(import_compiler.types.classBody([
      import_compiler.types.classMethod("method", import_compiler.types.identifier("onCreate"), [], import_compiler.types.blockStatement([
        import_compiler.types.expressionStatement(import_compiler.types.assignmentExpression("=", import_compiler.types.memberExpression(import_compiler.types.thisExpression(), import_compiler.types.identifier("state")), import_compiler.types.objectExpression([])))
      ]))
    ])),
    import_compiler.types.markoScriptlet([
      import_compiler.types.variableDeclaration("var", [
        import_compiler.types.variableDeclarator(meta.component, import_compiler.types.identifier("component")),
        import_compiler.types.variableDeclarator(meta.state, import_compiler.types.identifier("state"))
      ])
    ])
  ];
}
function buildNestedLifecycle(tag) {
  var _a;
  const meta = tag.node.extra.___lifecycle;
  const body = [];
  const result = [];
  for (const child of tag.node.body.body) {
    if ((_a = child.extra) == null ? void 0 : _a._hoistInInstance) {
      result.push(child);
    } else {
      body.push(child);
    }
  }
  result.push(import_compiler.types.markoTag(import_compiler.types.stringLiteral(meta.client ? "_instance" : "_instance-stateless"), [], import_compiler.types.markoTagBody(body, [
    tag.scope.generateUidIdentifier("nestedComponentDef"),
    meta.component,
    meta.state
  ])));
  return result;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  closest,
  ensureLifecycle
});
