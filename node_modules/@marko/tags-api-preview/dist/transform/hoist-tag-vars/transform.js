var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var transform_exports = {};
__export(transform_exports, {
  default: () => transform_default
});
module.exports = __toCommonJS(transform_exports);
var import_compiler = require("@marko/compiler");
var import_babel_utils = require("@marko/babel-utils");
var import_is_core_tag = __toESM(require("../../util/is-core-tag"));
var import_import_runtime = require("../../util/import-runtime");
var import_wrapper_component = require("../wrapper-component");
var ScopeRelation = /* @__PURE__ */ ((ScopeRelation2) => {
  ScopeRelation2[ScopeRelation2["Same"] = 0] = "Same";
  ScopeRelation2[ScopeRelation2["Before"] = 1] = "Before";
  ScopeRelation2[ScopeRelation2["After"] = 2] = "After";
  return ScopeRelation2;
})(ScopeRelation || {});
var ReferenceType = /* @__PURE__ */ ((ReferenceType2) => {
  ReferenceType2[ReferenceType2["Sync"] = 0] = "Sync";
  ReferenceType2[ReferenceType2["Async"] = 1] = "Async";
  ReferenceType2[ReferenceType2["Unknown"] = 2] = "Unknown";
  return ReferenceType2;
})(ReferenceType || {});
var transform_default = {
  MarkoTag: {
    exit(tag) {
      if (!tag.node.var) {
        return;
      }
      const {
        scope,
        hub: { file }
      } = tag;
      const tagVar = tag.get("var");
      const initializers = [];
      const meta = (0, import_wrapper_component.closest)(tag.parentPath);
      for (const name in tagVar.getBindingIdentifiers()) {
        const binding = scope.getBinding(name);
        if (binding && binding.scope !== scope) {
          const hoistedId = binding.scope.generateUidIdentifier(`${binding.identifier.name}_hoisted`);
          let maybeHasSyncRefsBefore = false;
          const [assignment] = binding.constantViolations;
          if (assignment) {
            throw assignment.buildCodeFrameError(`Assigning to a hoisted tag variable is not supported in the tags api preview.`);
          }
          for (const ref of binding.referencePaths) {
            if (getScopeRelation(binding.scope, tag, ref) === 1 /* Before */) {
              switch (getReferenceType(ref)) {
                case 1 /* Async */:
                  break;
                case 0 /* Sync */:
                  throw ref.buildCodeFrameError(`Cannot access '${name}' before initialization.`);
                case 2 /* Unknown */:
                  maybeHasSyncRefsBefore = true;
                  ref.replaceWith(import_compiler.types.assignmentExpression("=", ref.node, import_compiler.types.callExpression(hoistedId, [])));
                  break;
              }
            }
          }
          const hoistedDeclarators = [
            import_compiler.types.variableDeclarator(binding.identifier)
          ];
          if (maybeHasSyncRefsBefore) {
            hoistedDeclarators.push(import_compiler.types.variableDeclarator(hoistedId, import_compiler.types.callExpression((0, import_import_runtime.importRuntimeDefault)(file, "transform/hoist-tag-vars", "hoist"), [
              (0, import_wrapper_component.closest)(binding.scope.path).component,
              import_compiler.types.stringLiteral(name),
              import_compiler.types.arrowFunctionExpression([import_compiler.types.identifier("_")], import_compiler.types.assignmentExpression("=", binding.identifier, import_compiler.types.identifier("_")))
            ])));
            initializers.push(import_compiler.types.expressionStatement(import_compiler.types.callExpression(hoistedId, [
              meta.component,
              binding.identifier
            ])));
          } else {
            hoistedDeclarators.push(import_compiler.types.variableDeclarator(hoistedId, import_compiler.types.arrowFunctionExpression([import_compiler.types.identifier("_")], import_compiler.types.assignmentExpression("=", binding.identifier, import_compiler.types.identifier("_")))));
            initializers.push(import_compiler.types.expressionStatement(import_compiler.types.callExpression(hoistedId, [binding.identifier])));
          }
          binding.scope.path.unshiftContainer("body", import_compiler.types.markoScriptlet([import_compiler.types.variableDeclaration("var", hoistedDeclarators)]));
        }
      }
      if (initializers.length) {
        tag.parentPath.pushContainer("body", import_compiler.types.markoScriptlet(initializers));
      }
    }
  }
};
function getScopeRelation(scope, tag, ref) {
  const matchingScope = (parent) => parent.scope === scope && (parent.isMarkoScriptlet() || parent.isMarkoPlaceholder() || parent.isMarkoTag());
  const refParent = ref.findParent(matchingScope);
  const tagParent = tag.findParent(matchingScope);
  if (refParent.key === tagParent.key) {
    return 0 /* Same */;
  }
  return refParent.key < tagParent.key ? 1 /* Before */ : 2 /* After */;
}
function getReferenceType(ref) {
  let scope = ref.scope;
  while (scope.path.key === "callee" && scope.path.parentPath.isCallExpression()) {
    scope = scope.parent;
  }
  if (import_compiler.types.isProgram(scope.block) || import_compiler.types.isMarkoTagBody(scope.block)) {
    return 0 /* Sync */;
  }
  const closest2 = ref.findParent((parent) => parent.isMarkoAttribute());
  if (closest2) {
    const closestTag = closest2.parentPath;
    if ((0, import_babel_utils.isNativeTag)(closestTag) || (0, import_is_core_tag.default)("effect", closestTag) || (0, import_is_core_tag.default)("lifecycle", closestTag)) {
      return 1 /* Async */;
    }
  }
  return 2 /* Unknown */;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
