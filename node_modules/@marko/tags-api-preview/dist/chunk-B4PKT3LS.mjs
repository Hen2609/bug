import {
  buildAggregateError,
  init_build_aggregate_error
} from "./chunk-QPKFPRYE.mjs";
import {
  init_taglib_id,
  taglibId
} from "./chunk-45C4GXDQ.mjs";
import {
  __esm
} from "./chunk-XYON6ZHC.mjs";

// src/transform/feature-detection.ts
import { getTagDef, isDynamicTag } from "@marko/babel-utils";
function addFeature(state, type, name, path) {
  if (state.feature) {
    if (state.feature.type !== type) {
      throw buildAggregateError(path.hub.file, 'Cannot mix "tags api" and "class api" features', [state.feature.name, state.feature.path], [name, path]);
    }
  } else {
    state.feature = {
      name,
      path,
      type
    };
  }
}
var featureDetectionVisitor, feature_detection_default;
var init_feature_detection = __esm({
  "src/transform/feature-detection.ts"() {
    init_taglib_id();
    init_build_aggregate_error();
    featureDetectionVisitor = {
      MarkoComment(comment, state) {
        if (/^\s*use tags\s*$/.test(comment.node.value)) {
          addFeature(state, "tags", "<!-- use tags -->", comment);
        }
      },
      MarkoScriptlet(scriptlet, state) {
        if (!scriptlet.node.static) {
          addFeature(state, "class", "Scriptlet", scriptlet);
        }
      },
      MarkoClass(markoClass, state) {
        addFeature(state, "class", "Class block", markoClass.get("body"));
      },
      ReferencedIdentifier(ref, state) {
        const name = ref.node.name;
        if ((name === "input" || name === "component" || name === "out") && !ref.scope.hasBinding(name)) {
          addFeature(state, "class", `${name} template global`, ref);
        }
      },
      MarkoTag(tag, state) {
        var _a, _b;
        if (tag.node.var) {
          addFeature(state, "tags", "Tag variable", tag.get("var"));
        }
        for (const attr of tag.get("attributes")) {
          if (attr.isMarkoAttribute()) {
            if ((_a = attr.node.arguments) == null ? void 0 : _a.length) {
              addFeature(state, "class", "Attribute arguments", attr.get("arguments")[0]);
              break;
            } else if (attr.node.modifier) {
              addFeature(state, "class", "Attribute modifier", attr);
              break;
            } else if (attr.node.bound) {
              addFeature(state, "tags", "Bound attribute", attr);
              break;
            }
          }
        }
        const tagDef = getTagDef(tag);
        if (tagDef) {
          switch (tagDef.taglibId) {
            case "marko-html":
            case "marko-math":
            case "marko-svg": {
              for (const attr of tag.get("attributes")) {
                if (attr.isMarkoAttribute()) {
                  switch (attr.node.name) {
                    case "key":
                    case "no-update":
                    case "no-update-if":
                    case "no-update-body-if":
                      addFeature(state, "class", `"${attr.node.name}" attribute`, attr);
                      break;
                  }
                }
              }
              break;
            }
            case "marko-default-core":
              switch (tagDef.name) {
                case "if":
                case "for":
                case "else":
                case "else-if":
                case "import":
                case "style":
                case "html-comment":
                case "body":
                case "head":
                  break;
                default:
                  addFeature(state, "class", `<${tagDef.name}> tag`, tag.get("name"));
                  break;
              }
              break;
            case taglibId:
              switch (tagDef.name) {
                case "if":
                case "else-if":
                case "for":
                case "style":
                  break;
                default:
                  addFeature(state, "tags", `<${tagDef.name}> tag`, tag.get("name"));
              }
              break;
          }
        } else if (isDynamicTag(tag) && ((_b = tag.node.arguments) == null ? void 0 : _b.length)) {
          addFeature(state, "class", "Dynamic tag arguments", tag);
        }
      }
    };
    feature_detection_default = {
      Program(program) {
        var _a, _b, _c;
        const state = {};
        (_b = (_a = program.node).extra) != null ? _b : _a.extra = {};
        program.traverse(featureDetectionVisitor, state);
        program.node.extra.___featureType = ((_c = state.feature) == null ? void 0 : _c.type) || "class";
      }
    };
  }
});

export {
  feature_detection_default,
  init_feature_detection
};
