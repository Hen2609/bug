var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var import_path = __toESM(require("path"));
var import_magic_string = __toESM(require("magic-string"));
var import_compiler = require("@marko/compiler");
var import_babel_utils = require("@marko/babel-utils");
var import_get_attr = __toESM(require("../../util/get-attr"));
var import_is_api = __toESM(require("../../util/is-api"));
const STYLE_REG = /^style((?:\.[^\s\\/:*?"<>|({]+)+)?/;
const styleIndexes = /* @__PURE__ */ new WeakMap();
module.exports = (tag) => {
  var _a, _b;
  if ((0, import_is_api.default)(tag, "class"))
    return;
  const {
    hub: { file },
    node
  } = tag;
  const { deps } = file.metadata.marko;
  const filename = file.opts.filename;
  const typeValue = (_a = (0, import_get_attr.default)(tag, "class")) == null ? void 0 : _a.get("value");
  const [, type = ".css"] = STYLE_REG.exec(node.rawValue || "style");
  if (typeValue) {
    node.attributes.pop();
  }
  const errorMessage = node.attributes.length > 0 ? "does not support attributes" : !node.body.body.length ? "requires body content" : node.body.params.length ? "does not support tag body parameters" : ((_b = node.arguments) == null ? void 0 : _b.length) ? "does not support arguments" : typeValue && (!typeValue.isStringLiteral() || `.${typeValue.node.value.replace(/ /g, ".")}` !== type) ? "invalid class attribute" : void 0;
  if (errorMessage) {
    throw tag.get("name").buildCodeFrameError(`The <style> tag ${errorMessage}.`);
  }
  if (node.body.body.length > 1) {
    for (const child of tag.get("body").get("body")) {
      if (!child.isMarkoText()) {
        throw child.buildCodeFrameError("The <style> tag does not support dynamic placeholders.");
      }
    }
  }
  const styleIndex = styleIndexes.get(file) || 0;
  const base = import_path.default.basename(filename);
  const text = node.body.body[0];
  const virtualPath = `./${base + (styleIndex ? `.${styleIndex}` : "") + (node.var ? `.module.${type}` : type)}`;
  let code = text.value;
  styleIndexes.set(file, styleIndex + 1);
  if (node.var) {
    const { sourceMaps } = file.opts;
    const { resolveVirtualDependency } = file.markoOpts;
    let map;
    if (!resolveVirtualDependency) {
      throw tag.buildCodeFrameError(`@marko/tags-api-preview: the "resolveVirtualDependency" option must be supplied when using "style" with a tag variable.`);
    }
    if (sourceMaps && text.start != null && text.end != null) {
      map = new import_magic_string.default(file.code, { filename }).snip(text.start, text.end).generateMap({
        source: filename,
        includeContent: true
      });
      if (sourceMaps === "inline" || sourceMaps === "both") {
        code += `
/*# sourceMappingURL=${map.toUrl()}*/`;
        if (sourceMaps === "inline") {
          map = void 0;
        }
      }
    }
    const resolved = (0, import_babel_utils.resolveRelativePath)(file, resolveVirtualDependency(filename, {
      virtualPath,
      map,
      code
    }));
    deps.push(resolved);
    tag.replaceWith(import_compiler.types.markoScriptlet([
      import_compiler.types.variableDeclaration("const", [
        import_compiler.types.variableDeclarator(node.var, (0, import_babel_utils.importDefault)(file, resolved, "style"))
      ])
    ]));
  } else {
    const dep = {
      type: type.slice(1),
      style: true,
      code,
      startPos: text.start,
      endPos: text.end,
      path: `./${base}`,
      virtualPath
    };
    deps.push(dep);
    tag.remove();
  }
};
