import {
  init_transform as init_transform2,
  replaceAssignments
} from "../../chunk-UOJOZA4O.mjs";
import {
  init_transform,
  transform_default
} from "../../chunk-YQG3LUWZ.mjs";
import "../../chunk-BCNAFPHP.mjs";
import {
  closest,
  init_wrapper_component
} from "../../chunk-TFXOVXSS.mjs";
import "../../chunk-45C4GXDQ.mjs";
import "../../chunk-EGIQZ5A4.mjs";
import {
  __commonJS
} from "../../chunk-XYON6ZHC.mjs";

// src/components/let/translate.ts
import { types as t } from "@marko/compiler";
var require_translate = __commonJS({
  "src/components/let/translate.ts"(exports, module) {
    init_transform();
    init_wrapper_component();
    init_transform2();
    module.exports = function translate(tag) {
      var _a;
      const { file } = tag.hub;
      const server = file.markoOpts.output === "html";
      const tagVar = tag.node.var;
      let defaultAttr;
      let changeAttr;
      let errorMessage;
      for (const attr of tag.get("attributes")) {
        if (attr.isMarkoAttribute()) {
          switch (attr.node.name) {
            case "default":
              defaultAttr = attr;
              continue;
            case "defaultChange":
              changeAttr = attr;
              continue;
          }
        }
        errorMessage = `does not support the "${attr.toString()}" attribute`;
        break;
      }
      errorMessage = errorMessage || (!tagVar ? "requires a tag variable" : !t.isIdentifier(tagVar) ? "tag variable cannot be destructured" : tag.node.body.body.length ? "does not support body content" : tag.node.body.params.length ? "does not support tag body parameters" : ((_a = tag.node.arguments) == null ? void 0 : _a.length) ? "does not support arguments" : void 0);
      if (errorMessage) {
        throw tag.get("name").buildCodeFrameError(`The <let> tag ${errorMessage}.`);
      }
      file.path.scope.crawl();
      const defaultValue = defaultAttr ? defaultAttr.node.value : t.unaryExpression("void", t.numericLiteral(0));
      const binding = tag.scope.getBinding(tagVar.name);
      if (server) {
        file.path.scope.crawl();
        tag.replaceWith(t.variableDeclaration("const", [
          t.variableDeclarator(tagVar, transform_default(file, defaultValue))
        ]));
      } else {
        const meta = closest(tag.parentPath);
        const keyString = t.stringLiteral("" + meta.stateIndex++);
        const newValueId = tag.scope.generateUidIdentifier(tagVar.name);
        const getStateExpr = t.conditionalExpression(t.binaryExpression("in", keyString, meta.state), t.memberExpression(meta.state, keyString, true), t.assignmentExpression("=", t.memberExpression(meta.state, keyString, true), transform_default(file, defaultValue)));
        if (changeAttr) {
          const changeFnId = tag.scope.generateUidIdentifier(`${tagVar.name}Change`);
          const decls = [
            t.variableDeclarator(changeFnId, changeAttr.node.value)
          ];
          let setFnId;
          if (t.isFunction(changeAttr.node.value)) {
            setFnId = changeFnId;
            decls.push(t.variableDeclarator(tagVar, defaultValue));
          } else {
            setFnId = tag.scope.generateUidIdentifier(`${tagVar.name}Set`);
            decls.push(t.variableDeclarator(setFnId, t.logicalExpression("||", changeFnId, t.arrowFunctionExpression([newValueId], t.callExpression(t.memberExpression(meta.component, t.identifier("setState")), [keyString, newValueId])))), t.variableDeclarator(tagVar, t.conditionalExpression(changeFnId, defaultValue, getStateExpr)));
          }
          tag.replaceWith(t.variableDeclaration("const", decls));
          replaceAssignments(binding, setFnId);
        } else {
          const setFnId = tag.scope.generateUidIdentifier(`${tagVar.name}Set`);
          tag.replaceWith(t.variableDeclaration("const", [
            t.variableDeclarator(tagVar, getStateExpr),
            t.variableDeclarator(setFnId, t.arrowFunctionExpression([newValueId], t.callExpression(t.memberExpression(meta.component, t.identifier("setState")), [keyString, newValueId])))
          ]));
          replaceAssignments(binding, setFnId);
        }
      }
    };
  }
});
export default require_translate();
