var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var import_compiler = require("@marko/compiler");
var import_transform = __toESM(require("../../util/deep-freeze/transform"));
var import_wrapper_component = require("../../transform/wrapper-component");
var import_transform2 = __toESM(require("../../util/replace-assignments/transform"));
module.exports = function translate(tag) {
  var _a;
  const { file } = tag.hub;
  const server = file.markoOpts.output === "html";
  const tagVar = tag.node.var;
  let defaultAttr;
  let changeAttr;
  let errorMessage;
  for (const attr of tag.get("attributes")) {
    if (attr.isMarkoAttribute()) {
      switch (attr.node.name) {
        case "default":
          defaultAttr = attr;
          continue;
        case "defaultChange":
          changeAttr = attr;
          continue;
      }
    }
    errorMessage = `does not support the "${attr.toString()}" attribute`;
    break;
  }
  errorMessage = errorMessage || (!tagVar ? "requires a tag variable" : !import_compiler.types.isIdentifier(tagVar) ? "tag variable cannot be destructured" : tag.node.body.body.length ? "does not support body content" : tag.node.body.params.length ? "does not support tag body parameters" : ((_a = tag.node.arguments) == null ? void 0 : _a.length) ? "does not support arguments" : void 0);
  if (errorMessage) {
    throw tag.get("name").buildCodeFrameError(`The <let> tag ${errorMessage}.`);
  }
  file.path.scope.crawl();
  const defaultValue = defaultAttr ? defaultAttr.node.value : import_compiler.types.unaryExpression("void", import_compiler.types.numericLiteral(0));
  const binding = tag.scope.getBinding(tagVar.name);
  if (server) {
    file.path.scope.crawl();
    tag.replaceWith(import_compiler.types.variableDeclaration("const", [
      import_compiler.types.variableDeclarator(tagVar, (0, import_transform.default)(file, defaultValue))
    ]));
  } else {
    const meta = (0, import_wrapper_component.closest)(tag.parentPath);
    const keyString = import_compiler.types.stringLiteral("" + meta.stateIndex++);
    const newValueId = tag.scope.generateUidIdentifier(tagVar.name);
    const getStateExpr = import_compiler.types.conditionalExpression(import_compiler.types.binaryExpression("in", keyString, meta.state), import_compiler.types.memberExpression(meta.state, keyString, true), import_compiler.types.assignmentExpression("=", import_compiler.types.memberExpression(meta.state, keyString, true), (0, import_transform.default)(file, defaultValue)));
    if (changeAttr) {
      const changeFnId = tag.scope.generateUidIdentifier(`${tagVar.name}Change`);
      const decls = [
        import_compiler.types.variableDeclarator(changeFnId, changeAttr.node.value)
      ];
      let setFnId;
      if (import_compiler.types.isFunction(changeAttr.node.value)) {
        setFnId = changeFnId;
        decls.push(import_compiler.types.variableDeclarator(tagVar, defaultValue));
      } else {
        setFnId = tag.scope.generateUidIdentifier(`${tagVar.name}Set`);
        decls.push(import_compiler.types.variableDeclarator(setFnId, import_compiler.types.logicalExpression("||", changeFnId, import_compiler.types.arrowFunctionExpression([newValueId], import_compiler.types.callExpression(import_compiler.types.memberExpression(meta.component, import_compiler.types.identifier("setState")), [keyString, newValueId])))), import_compiler.types.variableDeclarator(tagVar, import_compiler.types.conditionalExpression(changeFnId, defaultValue, getStateExpr)));
      }
      tag.replaceWith(import_compiler.types.variableDeclaration("const", decls));
      (0, import_transform2.default)(binding, setFnId);
    } else {
      const setFnId = tag.scope.generateUidIdentifier(`${tagVar.name}Set`);
      tag.replaceWith(import_compiler.types.variableDeclaration("const", [
        import_compiler.types.variableDeclarator(tagVar, getStateExpr),
        import_compiler.types.variableDeclarator(setFnId, import_compiler.types.arrowFunctionExpression([newValueId], import_compiler.types.callExpression(import_compiler.types.memberExpression(meta.component, import_compiler.types.identifier("setState")), [keyString, newValueId])))
      ]));
      (0, import_transform2.default)(binding, setFnId);
    }
  }
};
