import {
  init_is_at_root,
  isAtRoot
} from "../../chunk-MZJE7NCD.mjs";
import "../../chunk-MU57322L.mjs";
import "../../chunk-45C4GXDQ.mjs";
import {
  __commonJS
} from "../../chunk-XYON6ZHC.mjs";

// src/components/return/translate.ts
import { types as t } from "@marko/compiler";
var require_translate = __commonJS({
  "src/components/return/translate.ts"(exports, module) {
    init_is_at_root();
    var usedTag = /* @__PURE__ */ new WeakSet();
    function buildInputExpr(prop) {
      return t.memberExpression(t.identifier("input"), t.identifier(prop));
    }
    module.exports = (tag) => {
      var _a;
      const errorMessage = usedTag.has(tag.hub) ? "can only be used once within a template" : tag.node.var ? "does not support a tag variable" : !isAtRoot(tag) ? "can only used at the root of the template" : !tag.node.attributes.length ? "requires a default attribute" : tag.node.body.body.length ? "does not support body content" : tag.node.body.params.length ? "does not support tag body parameters" : ((_a = tag.node.arguments) == null ? void 0 : _a.length) ? "does not support arguments" : void 0;
      if (errorMessage) {
        throw tag.get("name").buildCodeFrameError(`The <return> tag ${errorMessage}.`);
      }
      usedTag.add(tag.hub);
      const props = [];
      for (const attr of tag.get("attributes")) {
        if (attr.isMarkoAttribute()) {
          props.push(t.objectProperty(t.stringLiteral(attr.node.name), attr.node.value));
        } else {
          props.push(t.spreadElement(attr.node.value));
        }
      }
      const returnInput = buildInputExpr("_return");
      tag.replaceWith(t.expressionStatement(t.logicalExpression("&&", returnInput, t.callExpression(returnInput, [
        t.objectExpression(props),
        t.numericLiteral(1)
      ]))));
    };
  }
});
export default require_translate();
