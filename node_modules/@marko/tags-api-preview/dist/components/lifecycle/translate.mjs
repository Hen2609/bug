import {
  importRuntimeDefault,
  init_import_runtime
} from "../../chunk-BCNAFPHP.mjs";
import {
  __commonJS
} from "../../chunk-XYON6ZHC.mjs";

// src/components/lifecycle/translate.ts
import { types as t } from "@marko/compiler";
var require_translate = __commonJS({
  "src/components/lifecycle/translate.ts"(exports, module) {
    init_import_runtime();
    var supportedAttrNames = /* @__PURE__ */ new Set(["onMount", "onUpdate", "onDestroy"]);
    module.exports = function translate(tag) {
      var _a;
      const { file } = tag.hub;
      const properties = [];
      let errorMessage = tag.node.var ? "does not support a tag variable" : tag.node.body.body.length ? "does not support body content" : tag.node.body.params.length ? "does not support tag body parameters" : ((_a = tag.node.arguments) == null ? void 0 : _a.length) ? "does not support arguments" : void 0;
      if (!errorMessage) {
        for (const attr of tag.get("attributes")) {
          if (attr.isMarkoAttribute()) {
            if (!supportedAttrNames.has(attr.node.name)) {
              errorMessage = `does not support the "${attr.node.name}" attribute`;
              break;
            }
            properties.push(t.objectProperty(t.stringLiteral(attr.node.name), attr.node.value));
          } else {
            errorMessage = `does not support ...spread attributes`;
            break;
          }
        }
        if (!properties.length && !errorMessage) {
          errorMessage = "requires an onMount, onUpdate or onDestroy attribute";
        }
      }
      if (errorMessage) {
        throw tag.get("name").buildCodeFrameError(`The <lifecycle> tag ${errorMessage}.`);
      }
      if (file.markoOpts.output === "html") {
        tag.remove();
        return;
      }
      tag.replaceWith(t.expressionStatement(t.callExpression(importRuntimeDefault(file, "components/lifecycle", "lifecycle"), [
        file._componentInstanceIdentifier,
        t.objectExpression(properties)
      ])));
    };
  }
});
export default require_translate();
