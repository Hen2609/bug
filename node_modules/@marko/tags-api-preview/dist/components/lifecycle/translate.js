var import_compiler = require("@marko/compiler");
var import_import_runtime = require("../../util/import-runtime");
const supportedAttrNames = /* @__PURE__ */ new Set(["onMount", "onUpdate", "onDestroy"]);
module.exports = function translate(tag) {
  var _a;
  const { file } = tag.hub;
  const properties = [];
  let errorMessage = tag.node.var ? "does not support a tag variable" : tag.node.body.body.length ? "does not support body content" : tag.node.body.params.length ? "does not support tag body parameters" : ((_a = tag.node.arguments) == null ? void 0 : _a.length) ? "does not support arguments" : void 0;
  if (!errorMessage) {
    for (const attr of tag.get("attributes")) {
      if (attr.isMarkoAttribute()) {
        if (!supportedAttrNames.has(attr.node.name)) {
          errorMessage = `does not support the "${attr.node.name}" attribute`;
          break;
        }
        properties.push(import_compiler.types.objectProperty(import_compiler.types.stringLiteral(attr.node.name), attr.node.value));
      } else {
        errorMessage = `does not support ...spread attributes`;
        break;
      }
    }
    if (!properties.length && !errorMessage) {
      errorMessage = "requires an onMount, onUpdate or onDestroy attribute";
    }
  }
  if (errorMessage) {
    throw tag.get("name").buildCodeFrameError(`The <lifecycle> tag ${errorMessage}.`);
  }
  if (file.markoOpts.output === "html") {
    tag.remove();
    return;
  }
  tag.replaceWith(import_compiler.types.expressionStatement(import_compiler.types.callExpression((0, import_import_runtime.importRuntimeDefault)(file, "components/lifecycle", "lifecycle"), [
    file._componentInstanceIdentifier,
    import_compiler.types.objectExpression(properties)
  ])));
};
