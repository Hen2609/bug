"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  default: () => markoPlugin
});
module.exports = __toCommonJS(src_exports);
var import_os = __toESM(require("os"));
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var import_crypto = __toESM(require("crypto"));
var import_anymatch = __toESM(require("anymatch"));
var import_url = require("url");
var import_relative_import_path = require("relative-import-path");
var import_server_entry_template = __toESM(require("./server-entry-template"));
var import_manifest_generator = require("./manifest-generator");
var import_esbuild_plugin = __toESM(require("./esbuild-plugin"));
const import_meta = {};
const normalizePath = import_path.default.sep === "\\" ? (id) => id.replace(/\\/g, "/") : (id) => id;
const virtualFiles = /* @__PURE__ */ new Map();
const queryReg = /\?marko-.+$/;
const browserEntryQuery = "?marko-browser-entry";
const serverEntryQuery = "?marko-server-entry";
const virtualFileQuery = "?marko-virtual";
const markoExt = ".marko";
const htmlExt = ".html";
const resolveOpts = { skipSelf: true };
const cache = /* @__PURE__ */ new Map();
const thisFile = typeof __filename === "string" ? __filename : (0, import_url.fileURLToPath)(import_meta.url);
let tempDir;
function markoPlugin(opts = {}) {
  var _a;
  let compiler;
  const { runtimeId, linked = true } = opts;
  const baseConfig = {
    cache,
    runtimeId,
    sourceMaps: true,
    writeVersionComment: false,
    babelConfig: {
      ...opts.babelConfig,
      caller: {
        name: "@marko/vite",
        supportsStaticESM: true,
        supportsDynamicImport: true,
        supportsTopLevelAwait: true,
        supportsExportNamespaceFrom: true,
        ...(_a = opts.babelConfig) == null ? void 0 : _a.caller
      }
    }
  };
  const resolveViteVirtualDep = (from, dep) => {
    const query = `${virtualFileQuery}&id=${normalizePath(dep.virtualPath)}`;
    const id = normalizePath(from) + query;
    if (devServer) {
      const prev = virtualFiles.get(id);
      if (prev && prev.code !== dep.code) {
        devServer.moduleGraph.invalidateModule(devServer.moduleGraph.getModuleById(id));
      }
    }
    virtualFiles.set(id, dep);
    return `./${import_path.default.basename(from) + query}`;
  };
  const ssrConfig = {
    ...baseConfig,
    resolveVirtualDependency: resolveViteVirtualDep,
    output: "html"
  };
  const domConfig = {
    ...baseConfig,
    resolveVirtualDependency: resolveViteVirtualDep,
    output: "dom"
  };
  const hydrateConfig = {
    ...baseConfig,
    resolveVirtualDependency: resolveViteVirtualDep,
    output: "hydrate"
  };
  let root;
  let devEntryFile;
  let isBuild = false;
  let isSSRBuild = false;
  let devServer;
  let registeredTag = false;
  let serverManifest;
  const entrySources = /* @__PURE__ */ new Map();
  const transformWatchFiles = /* @__PURE__ */ new Map();
  const transformOptionalFiles = /* @__PURE__ */ new Map();
  return [
    {
      name: "marko-vite:pre",
      enforce: "pre",
      async config(config, env) {
        compiler ?? (compiler = await import(opts.compiler || "@marko/compiler"));
        root = normalizePath(config.root || process.cwd());
        devEntryFile = import_path.default.join(root, "index.html");
        isBuild = env.command === "build";
        isSSRBuild = isBuild && linked && Boolean(config.build.ssr);
        if (linked && !registeredTag) {
          const transformer = import_path.default.resolve(thisFile, "../render-assets-transform");
          registeredTag = normalizePath(import_path.default.resolve(thisFile, "../components", "vite.marko"));
          compiler.taglib.register("@marko/vite", {
            "<_vite>": { template: registeredTag },
            "<head>": { transformer },
            "<body>": { transformer }
          });
        }
        const lookup = compiler.taglib.buildLookup(root);
        const taglibDeps = [];
        for (const name in lookup.taglibsById) {
          const taglib = lookup.taglibsById[name];
          if (!/^marko-(.+-)?core$/.test(taglib.id) && /[\\/]node_modules[\\/]/.test(taglib.dirname)) {
            for (const tagName in taglib.tags) {
              const tag = taglib.tags[tagName];
              const entry = tag.template || tag.renderer;
              if (entry) {
                taglibDeps.push((0, import_relative_import_path.relativeImportPath)(devEntryFile, entry));
              }
            }
          }
        }
        const optimizeDeps = config.optimizeDeps ?? (config.optimizeDeps = {});
        optimizeDeps.include = Array.from(/* @__PURE__ */ new Set([
          ...optimizeDeps.include || [],
          ...compiler.getRuntimeEntryFiles("dom", opts.translator),
          ...compiler.getRuntimeEntryFiles("html", opts.translator),
          ...taglibDeps
        ]));
        const optimizeExtensions = optimizeDeps.extensions ?? (optimizeDeps.extensions = []);
        optimizeExtensions.push(".marko");
        const esbuildOptions = optimizeDeps.esbuildOptions ?? (optimizeDeps.esbuildOptions = {});
        const esbuildPlugins = esbuildOptions.plugins ?? (esbuildOptions.plugins = []);
        esbuildPlugins.push((0, import_esbuild_plugin.default)(compiler, baseConfig));
        const ssr = config.ssr ?? (config.ssr = {});
        if (ssr.noExternal !== true) {
          ssr.noExternal = Array.from(new Set(taglibDeps.concat(ssr.noExternal || [])));
        }
      },
      configureServer(_server) {
        ssrConfig.hot = domConfig.hot = true;
        devServer = _server;
        devServer.watcher.on("all", (type, filename) => {
          if (type === "unlink") {
            entrySources.delete(filename);
          }
          for (const [id, files] of transformWatchFiles) {
            if ((0, import_anymatch.default)(files, filename)) {
              devServer.watcher.emit("change", id);
            }
          }
          if (type === "add" || type === "unlink") {
            let clearedCache = false;
            for (const [id, files] of transformOptionalFiles) {
              if ((0, import_anymatch.default)(files, filename)) {
                if (!clearedCache) {
                  baseConfig.cache.clear();
                  clearedCache = true;
                }
                devServer.watcher.emit("change", id);
              }
            }
          }
        });
      },
      async buildStart(inputOptions) {
        if (isBuild && linked && !isSSRBuild) {
          const serverMetaFile = await getServerManifestFile(root);
          this.addWatchFile(serverMetaFile);
          try {
            serverManifest = JSON.parse(await import_fs.default.promises.readFile(serverMetaFile, "utf-8"));
            inputOptions.input = toHTMLEntries(root, serverManifest.entries);
            for (const entry in serverManifest.entrySources) {
              entrySources.set(import_path.default.resolve(root, entry), serverManifest.entrySources[entry]);
            }
          } catch (err) {
            this.error(`You must run the "ssr" build before the "browser" build.`);
          }
          if (isEmpty(inputOptions.input)) {
            this.error("No Marko files were found when compiling the server.");
          }
        }
      },
      async resolveId(importee, importer, importOpts, ssr = importOpts.ssr) {
        var _a2;
        if (virtualFiles.has(importee)) {
          return importee;
        }
        let importeeQuery = getMarkoQuery(importee);
        if (importeeQuery) {
          importee = importee.slice(0, -importeeQuery.length);
        } else if (ssr && linked && importer && importer !== devEntryFile && isMarkoFile(importee) && !isMarkoFile(importer.replace(queryReg, ""))) {
          importeeQuery = serverEntryQuery;
        } else if (!ssr && isBuild && importer && isMarkoFile(importee) && ((_a2 = this.getModuleInfo(importer)) == null ? void 0 : _a2.isEntry)) {
          importeeQuery = browserEntryQuery;
        }
        if (importeeQuery) {
          const resolved = importee[0] === "." ? {
            id: normalizePath(importer ? import_path.default.resolve(importer, "..", importee) : import_path.default.resolve(root, importee))
          } : await this.resolve(importee, importer, resolveOpts);
          if (resolved) {
            resolved.id += importeeQuery;
          }
          return resolved;
        }
        if (importer) {
          const importerQuery = getMarkoQuery(importer);
          if (importerQuery) {
            importer = importer.slice(0, -importerQuery.length);
            if (importee[0] === ".") {
              const resolved = import_path.default.resolve(importer, "..", importee);
              if (resolved === importer)
                return resolved;
            }
            return this.resolve(importee, importer, resolveOpts);
          }
        }
        return null;
      },
      async load(id) {
        switch (getMarkoQuery(id)) {
          case serverEntryQuery: {
            const fileName = id.slice(0, -serverEntryQuery.length);
            let entryData;
            entrySources.set(fileName, "");
            if (isBuild) {
              const relativeFileName = import_path.default.posix.relative(root, fileName);
              const entryId = toEntryId(relativeFileName);
              serverManifest ?? (serverManifest = {
                entries: {},
                entrySources: {},
                chunksNeedingAssets: []
              });
              serverManifest.entries[entryId] = relativeFileName;
              entryData = JSON.stringify(entryId);
            } else {
              entryData = JSON.stringify(await (0, import_manifest_generator.generateDocManifest)(await devServer.transformIndexHtml("/", (0, import_manifest_generator.generateInputDoc)(fileNameToURL(fileName, root)))));
            }
            return (0, import_server_entry_template.default)({
              fileName,
              entryData,
              runtimeId
            });
          }
          case browserEntryQuery: {
            return entrySources.get(id.slice(0, -browserEntryQuery.length));
          }
        }
        return virtualFiles.get(id) || null;
      },
      async transformIndexHtml(html) {
        if (isBuild) {
          return html;
        }
        return html.replace(/(src\s*=\s*(['"])(?:(?!\2).)*\.marko)(?:\?((?:(?!\2).)*))?\2/gim, (_, prefix, quote, query) => prefix + browserEntryQuery + (query ? "&" + query : "") + quote);
      },
      async transform(source, id, ssr) {
        const query = getMarkoQuery(id);
        if (query && !query.startsWith(virtualFileQuery)) {
          id = id.slice(0, -query.length);
          if (query === serverEntryQuery) {
            id = `${id.slice(0, -markoExt.length)}.entry.marko`;
          }
        }
        if (!isMarkoFile(id)) {
          return null;
        }
        if (ssr && entrySources.has(id)) {
          entrySources.set(id, source);
          if (serverManifest) {
            serverManifest.entrySources[import_path.default.relative(root, id)] = source;
          }
        }
        const compiled = await compiler.compile(source, id, (typeof ssr === "object" ? ssr.ssr : ssr) ? ssrConfig : query === browserEntryQuery ? hydrateConfig : domConfig);
        const { map, meta } = compiled;
        let { code } = compiled;
        if (query !== browserEntryQuery && devServer) {
          code += `
if (import.meta.hot) import.meta.hot.accept();`;
        }
        if (devServer) {
          const templateName = getBasenameWithoutExt(id);
          const optionalFilePrefix = import_path.default.dirname(id) + import_path.default.sep + (templateName === "index" ? "" : `${templateName}.`);
          for (const file of meta.watchFiles) {
            this.addWatchFile(file);
          }
          transformOptionalFiles.set(id, [
            `${optionalFilePrefix}style.*`,
            `${optionalFilePrefix}component.*`,
            `${optionalFilePrefix}component-browser.*`,
            `${optionalFilePrefix}marko-tag.json`
          ]);
          transformWatchFiles.set(id, meta.watchFiles);
        }
        return { code, map, meta: isBuild ? { source } : void 0 };
      }
    },
    {
      name: "marko-vite:post",
      apply: "build",
      enforce: "post",
      async generateBundle(outputOptions, bundle, isWrite) {
        if (!linked) {
          return;
        }
        if (!isWrite) {
          this.error(`Linked builds are currently only supported when in "write" mode.`);
        }
        if (!serverManifest) {
          this.error("No Marko files were found when bundling the server in linked mode.");
        }
        if (isSSRBuild) {
          const dir = outputOptions.dir ? import_path.default.resolve(outputOptions.dir) : import_path.default.resolve(outputOptions.file, "..");
          for (const fileName in bundle) {
            const chunk = bundle[fileName];
            if (chunk.type === "chunk") {
              for (const id in chunk.modules) {
                if (id === registeredTag) {
                  serverManifest.chunksNeedingAssets.push(import_path.default.resolve(dir, fileName));
                  break;
                }
              }
            }
          }
          await import_fs.default.promises.writeFile(await getServerManifestFile(root), JSON.stringify(serverManifest));
        } else {
          const browserManifest = {};
          for (const entryId in serverManifest.entries) {
            const fileName = serverManifest.entries[entryId];
            let chunkId = fileName + htmlExt;
            let chunk = bundle[chunkId];
            if (!chunk) {
              chunkId = chunkId.replace(/\//g, "\\");
              chunk = bundle[chunkId];
            }
            if ((chunk == null ? void 0 : chunk.type) === "asset") {
              browserManifest[entryId] = await (0, import_manifest_generator.generateDocManifest)(chunk.source.toString());
              delete bundle[chunkId];
            } else {
              this.error(`Marko template had unexpected output from vite, ${fileName}`);
            }
          }
          const manifestStr = `;var __MARKO_MANIFEST__=${JSON.stringify(browserManifest)};
`;
          for (const fileName of serverManifest.chunksNeedingAssets) {
            await import_fs.default.promises.appendFile(fileName, manifestStr);
          }
        }
      }
    }
  ];
}
function getMarkoQuery(id) {
  var _a;
  return ((_a = queryReg.exec(id)) == null ? void 0 : _a[0]) || "";
}
function isMarkoFile(id) {
  return id.endsWith(markoExt);
}
function toHTMLEntries(root, serverEntries) {
  const result = [];
  for (const id in serverEntries) {
    const markoFile = import_path.default.posix.join(root, serverEntries[id]);
    const htmlFile = markoFile + htmlExt;
    virtualFiles.set(htmlFile, {
      code: (0, import_manifest_generator.generateInputDoc)(markoFile)
    });
    result.push(htmlFile);
  }
  return result;
}
async function getServerManifestFile(root) {
  return import_path.default.join(await getTempDir(root), "manifest.json");
}
function getTempDir(root) {
  return tempDir || (tempDir = (async () => {
    const dir = import_path.default.join(import_os.default.tmpdir(), `marko-vite-${import_crypto.default.createHash("SHA1").update(root).digest("hex")}`);
    try {
      const stat = await import_fs.default.promises.stat(dir);
      if (stat.isDirectory()) {
        return dir;
      }
    } catch {
      await import_fs.default.promises.mkdir(dir);
      return dir;
    }
    throw new Error("Unable to create temp directory");
  })());
}
function toEntryId(id) {
  const lastSepIndex = id.lastIndexOf(import_path.default.sep);
  let name = id.slice(lastSepIndex + 1, id.indexOf(".", lastSepIndex));
  if (name === "index" || name === "template") {
    name = id.slice(id.lastIndexOf(import_path.default.sep, lastSepIndex - 1) + 1, lastSepIndex);
  }
  return `${name}_${import_crypto.default.createHash("SHA1").update(id).digest("base64").replace(/[/+]/g, "-").slice(0, 4)}`;
}
function fileNameToURL(fileName, root) {
  const relativeURL = import_path.default.posix.relative((0, import_url.pathToFileURL)(root).pathname, (0, import_url.pathToFileURL)(fileName).pathname);
  if (relativeURL[0] === ".") {
    throw new Error("@marko/vite: Entry templates must exist under the current root directory.");
  }
  return `/${relativeURL}`;
}
function getBasenameWithoutExt(file) {
  const baseStart = file.lastIndexOf(import_path.default.sep) + 1;
  const extStart = file.indexOf(".", baseStart + 1);
  return file.slice(baseStart, extStart);
}
function isEmpty(obj) {
  for (const _ in obj) {
    return false;
  }
  return true;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
